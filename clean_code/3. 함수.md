## 3. 함수

---

### 작게 만들어라

함수는 작게 만들어야 한다. 기능별로 쪼갤 수 있는 한 최대한 쪼개야 한다. 그래야 흐름대로 이해할 수 있다.

---

### 블록과 들여쓰기

if문 / else문 / while문에 들어가는 블록은 들여쓰기 수준이 1단이나 2단을 넘어가면 안된다. 들여쓰기가 깊어질만큼 함수를 크게 하면 안되기 때문에
적당한 수준에서 함수를 호출하도록 프로그래밍을 하도록 한다.

---

### 한가지만 해라

코드를 의미있는 다른 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 수행하는 것이다. 
따라서 의미를 유지하면서 추상화 수준을 더이상 쪼갤 수 없으면 여러가지 기능을 수행한다고 오해할 수 있더라도 하나의 기능만 수행하는 함수라고
할 수 있다.

---

### 함수 당 추상화 수준은 하나로!

.append()과 getHTML()를 비교했을 때, getHTML()과 같은 코드는 읽는 사람이 명확하게 이해할 수 있다. 이를 추상화 수준이 높다고 할 수 있다.
반면에 .append()와 같은 코드는 구현의 세부사항을 표현하는 코드이므로 추상화 수준이 낮다고 할 수 있다. 이 두개의 코드를 섞는다고 했을 때 코드를 읽는 사람이
헷갈릴 수 있다. 해당 표현이 근본 개념인지 세부사항인지 구분하기 어렵다. 뿐만 아니라, 근본 개념을 구현한 함수에 세부사항을 섞기 시작하면 다른 사람들도 세부사항을
계속해서 추가할 수 있기 때문에 함수 내에서는 동일한 추상화 수준을 갖도록 해야 한다.


#### 내려가기 규칙
코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. 일련의 TO 문단을 읽듯이 
코드를 구현하면 추상화 수준을 일관되게 유지하기 쉬워진다. 

---

### Switch문

Switch문은 작게 만들기 어렵다. 분기가 늘어날수록 함수가 길어질 수 밖에 없기 때문이다. 또 새로운 유형이 추가되면 반복적으로 다른 코드도 수정할 위험이 생긴다.
따라서 다형성을 이용한 추상 팩토리 패턴을 이용하여 switch문을 숨기도록 한다. 일반적으로 switch문은 한 번만 사용할 수 있도록 한다. 
다형적 객체를 생성하는 코드는 switch문이 불가피하므로, 한 번만 사용하고 다른 코드에는 노출되지 않도록 한다.

---

### 서술적인 이름을 사용하라!

함수 이름을 서술적으로 사용하여 역할을 좀 더 명확하게 표현하는 것이 좋다. 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 좋은 코드가 될 가능성이 높다.
길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 주석보다는 함수 이름을 통해서 명확하게 기능을 알 수 있는 것이 좋다. 

---

### 함수 인수

함수 인수는 적으면 적을수록 좋다. 가독성도 떨어질 뿐더러 코드를 테스트할 때 함수 인수의 갯수가 많아질수록 테스트 케이스의 조합 수가 많아지기 때문이다.
최선은 입력 인수가 없는 경우이고, 차선은 입력 인수가 1개뿐인 경우이다.

#### 1. 많이 쓰는 단항 형식

함수에 인수 1개를 넘기는 경우는 인수에 질문을 던지는 경우, 인수를 뭔가로 변환해 결과를 반환하는 경우가 있다.
예를 들어 인수에 질문을 던지는 경우는 boolean fileExists("MyFile") 과 같은 것이 있고, 인수를 변환해 결과를 반환하는 경우는
InputStream fileOpen("MyFile")처럼 MyFile이라는 파일 이름을 InputStream의 형태로 반환하는 것과 같은 것이 있다. 
이 두 가지를 제외하고는 단항 함수는 가급적 피해야 한다. 특히 void includeSetupPageInto(StringBuffer pageText)처럼 변환 함수에서
출력 인수를 사용하면 혼란을 일으킬 수 있다. 

#### 2. 플래그 인수

함수 인수로 boolean 타입의 플래그를 넘기는 것은 함수가 여러 가지 역할을 하겠다고 공표하는 것과 같다. 따라서 플래그 인수는 자제하도록 하고,
플래그 인수를 넘겨야 하는 경우는 함수 자체를 쪼갤 수 있는 상황이므로 함수를 쪼개는 것이 가장 좋다.

#### 3. 이항 함수

이항 함수는 기본적으로 단항 함수보다 이해하기 어렵다. 하지만 이항 함수가 적절한 경우도 있다. Point p = new Point(0, 0)과 같은
예다. 이 경우에는 인수는 2개지만 결국 한 값을 표현하는 두 요소다. 또 순서도 명확하게 정해져 있다. 하지만 한 값을 표현하지도, 순서도 정해져 있지 않은 경우에
함수를 두 개 이상으로 정의하면 이해하기 힘들어지기 때문에 가급적이면 단항 함수로 바꾸는 것이 좋다.

#### 4. 삼항 함수

삼항 함수를 만들 때는 이항 함수보다 더 이해하기 어려우므로 신중히 고려하자.

#### 5. 인수 객체

인수가 2~3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 생각한다.

```
ex)

Circle makeCircle(double x, double y, double radius);

-> Circle makeCircle(Point center, double radius);

```

위의 예와 같이 수정하게 되면 눈속임 같아 보일 수 있지만, 결국 변수를 묶어 넘기려면 이름을 붙여야 하므로 개념을 표현하게 된다.

#### 6. 인수 목록

인수 갯수가 가변적인 함수도 필요하다. string formatter와 같은 경우가 그렇다. 하지만 string formatter의 경우도
가변 인수들을 동등하게 취급하면 List형 인수 하나로 취급할 수 있기 때문에 결국 이항 함수가 된다.

#### 7. 동사와 키워드

함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다. 함수 이름에 키워드를 추가하거나 함수와 인수가 동사/명사 쌍을 이루도록
함수 이름을 지으면 함수 이름만으로 의도와 인수의 순서를 명확하게 파악할 수 있다.

---

### 부수 효과를 일으키지 마라!

함수에서 한 가지를 한다고 작성해놓고 은근슬쩍 부수적인 작업을 끼워넣는 경우가 있다. 이러한 경우에 부수적인 작업은 숨겨지므로 잘못된 사용을 유발할 수 있다.
따라서 함수가 '한 가지'만 한다는 규칙을 위반할지언정 부수적인 작업까지 함수 이름에 명시하는 것이 그나마 낫다.

#### 출력 인수

일반적으로 우리는 인수를 함수 입력으로 해석한다. 인수를 출력으로 사용하는 경우는 피해야 한다.

```python

# 이 함수와 같이 인수를 출력 인수로 사용하게 되면 함수의 선언부를 확인해야 쓰임새를 알 수 있다.
def appendFooter(report):
    print("footer = " + report)

# 객체 지향 프로그래밍이 가능하면 아래와 같이 멤버 변수로 저장해서 출력 인수를 지양하도록 한다.
class Report():
    def __init__(self):
        self.report = ""
        
    def appendFooter(self):
        print("footer = " + self.report)

```

---

### 명령과 조회를 분리하라!

함수는 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나만 해야 한다. 둘 다 하면 혼란을 초래할 수 있다.

```python
def set(attribute, value):
    pass

if set("username", "uncluebob"):
    pass

```
위와 같은 코드를 읽었을 때 "username"이 "uncluebob"으로 설정되어 있는지 확인하는 코드인지 아니면 설정하고 성공 여부를 반환하는 코드인지 헷갈린다.
함수 이름을 setAndCheckExist라고 바꿀 수 있지만 조금 어색할 수 있다. 따라서 명령과 조회는 구분되어야 한다.


---

### 오류 코드보다 예외를 사용하라!

명령 함수에서 오류 코드를 반환하는 형식은 명령/조회 분리 규칙을 위반할 수 있다. if문에서 명령을 표현식으로 사용하기 쉽기 때문이다.

```python

def delete_page(page):
    pass
 
if delete_page("my_page") == EOFError:
    pass
```
위와 같은 코드는 동사/형용사 혼란을 일으키진 않지만 여러 단계로 중첩되는 코드를 야기한다. 따라서 에러 코드를 확인한 후 부가 작업을 하는 것보다는 
try/catch문을 통해 예외 상황에 따른 처리를 하는 것이 더 좋다.

#### Try/Catch 블록 뽑아내기

try/catch 블록은 코드 구조에 혼란을 일으키고, 정상 동작과 오류 처리 동작을 뒤섞으므로 별도 함수로 뽑아내는 것이 좋다.

ex)
```python
def delete_page_and_all_references(page):
    pass

def log_error(exception):
    print(exception)
    
def delete(page):
    try:
        delete_page_and_all_references(page)
    
    except Exception as error:
        log_error(error)
```

---

### 반복하지 마라!

코드 중복은 항상 문제다. 코드 길이가 늘어날 뿐만 아니라 로직이 수정되면 전부 다 수정해야 하기 때문이다. 
소프트웨어에 있어서 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다. 따라서 중복은 반드시 제거하기 위해 노력해야 한다.

---

### 구조적 프로그래밍

구조적 프로그래밍 원칙은 모든 함수는 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다고 한다. 함수는 return문이 하나여야 하고,
루프 안에서 break나 continue를 사용해선 안되며 goto는 절대로 안된다. 하지만 함수가 작은 경우에는 이러한 규칙이 별로 도움이 되지 않는다.
따라서 함수를 작게 만든다면 return, break, continue를 여러 차례 사용하는 것이 더 의도를 잘 표현할 수 있다.

---

### 함수를 어떻게 짜죠?

코드를 짤 때 처음부터 완벽한 코드를 짤 순 없다. 처음에 짠 함수는 길고 복잡하고, 중복된 코드도 많아 엉망일 수 있다. 그런 코드를 빠짐없이 테스트하는
단위 테스트 케이스도 만든다. 그리고 나서 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 그리고 다시 단위 테스트를 통과시킨다.
이런식으로 리펙토링 과정을 거치면서 코드가 깨끗해지도록 해야 한다.

---





