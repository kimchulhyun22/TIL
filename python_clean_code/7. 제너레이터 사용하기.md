# 7. 제너레이터 사용하기

---

## 1. 제너레이터 만들기

제너레이터란?
- 제너레이터는 파이썬에서 고성능이면서도 메모리를 적게 사용하는 반복을 위한 방법이다.
- 제너레이터는 한 번에 하나씩 구성요소를 반환해주는 이터러블을 생성해주는 객체이다.

**제너레이터**를 사용하는 주요 목적은 메모리를 절약하는 것이다. 거대한 요소를 한꺼번에 메모리에 저장하는 것이 아니라 특정 요소를 어떻게 만드는지
아는 객체를 만들어서 필요할 때마다 하나씩만 가져오는 것이다.


### 제너레이터 개요

```python
class PurchasesStats:
    def __init__(self, purchases):
        self.purchases = iter(purchases)
        self.min_price: float = None
        self.max_price: float = None
        self._total_purchases_price: float = 0.0
        self._total_purchases = 0
        self._initialize()

    def _initialize(self):
        try:
            first_value = next(self.purchases)
        except StopIteration:
            raise ValueError("no values provided")

        self.min_price = self.max_price = first_value
        self._update_avg(first_value)

    def process(self):
        for purchase_value in self.purchases:
            self._update_min(purchase_value)
            self._update_max(purchase_value)
            self._update_avg(purchase_value)
        return self

    def _update_min(self, new_value: float):
        if new_value < self.min_price:
            self.min_price = new_value

    def _update_max(self, new_value: float):
        if new_value > self.max_price:
            self.max_price = new_value

    @property
    def avg_price(self):
        return self._total_purchases_price / self._total_purchases

    def _update_avg(self, new_value: float):
        self._total_purchases_price += new_value
        self._total_purchases += 1

    def __str__(self):
        return (
            f"{self.__class__.__name__}({self.min_price}, "
            f"{self.max_price}, {self.avg_price})"
        )
    

def _load_purchases(file_name):
    purchases = []
    
    with open(file_name) as f:
        for line in f:
            *_, price_raw = line.partition(",")
            purchases.append(float(price_raw))
    
    return purchases
```

파일이나 데이터베이스에서 모든 정보를 읽어서 리스트에 저장하는 경우 성능에 문제가 있다. 상당히 많은 데어티가 있다면 로드하는데 시간이 오래
걸리고 메인 메모리에 담지 못할 만큼 큰 데이터일수도 있다. 하지만 한 번에 하나의 데이터만을 사용하고 있다면 굳이 파일의 모든 데이터를 한 번에
모두 읽어 와서 메모리에 보관해야 할 이유가 없다. 따라서 **제너레이터**를 만들어 파일의 전체 내용을 리스트에 보관하지 않고 필요한 값만
그때그때 가져오는 것이다.

```python
def _load_purchases(filename):
    with open(filename) as f:
        for line in f:
            *_, price_raw = line.partition(",")
            yield float(price_raw)
```

_load_purchases 함수만 위와 같이 변경하면 결과를 담을 리스트가 필요없어져 메모리 사용량이 급격하게 떨어지는 것을 알 수 있다.
위 함수와 같이 yield 키워드를 사용하면 제너레이터 함수가 된다.

### 제너레이터 표현식

제너레이터는 이터레이터이므로 리스트나 튜플, 세트처럼 많은 메모리를 필요로 하는 이터러블이나 컨테이너의 대안이 될 수 있다.
컴프리핸션에 의해 정의될 수 있는 리스트나 세트, 사전처럼 제너레이터도 제너레이터 표현식으로 정의할 수 있다. 
또, 다른 컴프리핸션처럼 이터러블 연산이 가능한 함수에 전달할 수 있다.

```python
gen = (x ** 2 for x in range(10))
gen_sum = sum(gen)
gen_max = max(gen)
```

---


