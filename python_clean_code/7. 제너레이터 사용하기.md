# 7. 제너레이터 사용하기

---

## 1. 제너레이터 만들기

제너레이터란?
- 제너레이터는 파이썬에서 고성능이면서도 메모리를 적게 사용하는 반복을 위한 방법이다.
- 제너레이터는 한 번에 하나씩 구성요소를 반환해주는 이터러블을 생성해주는 객체이다.

**제너레이터**를 사용하는 주요 목적은 메모리를 절약하는 것이다. 거대한 요소를 한꺼번에 메모리에 저장하는 것이 아니라 특정 요소를 어떻게 만드는지
아는 객체를 만들어서 필요할 때마다 하나씩만 가져오는 것이다.


### 제너레이터 개요

```python
class PurchasesStats:
    def __init__(self, purchases):
        self.purchases = iter(purchases)
        self.min_price: float = None
        self.max_price: float = None
        self._total_purchases_price: float = 0.0
        self._total_purchases = 0
        self._initialize()

    def _initialize(self):
        try:
            first_value = next(self.purchases)
        except StopIteration:
            raise ValueError("no values provided")

        self.min_price = self.max_price = first_value
        self._update_avg(first_value)

    def process(self):
        for purchase_value in self.purchases:
            self._update_min(purchase_value)
            self._update_max(purchase_value)
            self._update_avg(purchase_value)
        return self

    def _update_min(self, new_value: float):
        if new_value < self.min_price:
            self.min_price = new_value

    def _update_max(self, new_value: float):
        if new_value > self.max_price:
            self.max_price = new_value

    @property
    def avg_price(self):
        return self._total_purchases_price / self._total_purchases

    def _update_avg(self, new_value: float):
        self._total_purchases_price += new_value
        self._total_purchases += 1

    def __str__(self):
        return (
            f"{self.__class__.__name__}({self.min_price}, "
            f"{self.max_price}, {self.avg_price})"
        )
    

def _load_purchases(file_name):
    purchases = []
    
    with open(file_name) as f:
        for line in f:
            *_, price_raw = line.partition(",")
            purchases.append(float(price_raw))
    
    return purchases
```

파일이나 데이터베이스에서 모든 정보를 읽어서 리스트에 저장하는 경우 성능에 문제가 있다. 상당히 많은 데어티가 있다면 로드하는데 시간이 오래
걸리고 메인 메모리에 담지 못할 만큼 큰 데이터일수도 있다. 하지만 한 번에 하나의 데이터만을 사용하고 있다면 굳이 파일의 모든 데이터를 한 번에
모두 읽어 와서 메모리에 보관해야 할 이유가 없다. 따라서 **제너레이터**를 만들어 파일의 전체 내용을 리스트에 보관하지 않고 필요한 값만
그때그때 가져오는 것이다.

```python
def _load_purchases(filename):
    with open(filename) as f:
        for line in f:
            *_, price_raw = line.partition(",")
            yield float(price_raw)
```

_load_purchases 함수만 위와 같이 변경하면 결과를 담을 리스트가 필요없어져 메모리 사용량이 급격하게 떨어지는 것을 알 수 있다.
위 함수와 같이 yield 키워드를 사용하면 제너레이터 함수가 된다.

### 제너레이터 표현식

제너레이터는 이터레이터이므로 리스트나 튜플, 세트처럼 많은 메모리를 필요로 하는 이터러블이나 컨테이너의 대안이 될 수 있다.
컴프리핸션에 의해 정의될 수 있는 리스트나 세트, 사전처럼 제너레이터도 제너레이터 표현식으로 정의할 수 있다. 
또, 다른 컴프리핸션처럼 이터러블 연산이 가능한 함수에 전달할 수 있다.

```python
gen = (x ** 2 for x in range(10))
gen_sum = sum(gen)
gen_max = max(gen)
```

---

## 2. 이상적인 반복

제너레이터를 이용하면 반복을 할 때 유용하게 사용할 수 있는 코드를 작성할 수 있다.

### 관용적인 반복 코드

우리는 내장 함수인 enumerate()에 익숙하다. 이 함수는 이터러블을 입력 받아서 인덱스 번호와 원본의 원소를 튜플 형태로 변환하여 enumerate 객체를 반환한다.
이것을 좀 더 저수준에서 구현해보도록 하자.

```python
class SequenceOfNumbers:
    def __init__(self, start=0):
        self.current = start

    def __next__(self):
        current = self.current
        self.current += 1

        return current

    def __iter__(self):
        return self


for i in SequenceOfNumbers():
    print(i)
```

__ iter __ 매직 메서드를 구현하면 반복 가능한 객체를 만들 수 있고, __ next __ 매직 메서드를 구현하면 객체는 이터레이터가 된다.

#### 1) next() 함수

next() 내장 함수는 이터러블을 다음 요소로 이동시키고 기존의 값을 반환한다. 이터레이터가 더 이상의 값을 가지고 있지 않다면 StopIteration 예외가 발생한다.

#### 2) 제너레이터 사용하기

위의 코드는 제너레이터로 바꿀 수 있다. 클래스 대신 필요한 값을 yield하는 함수를 만들면 된다.

```python
def sequence(start=0):
    while True:
        yield start
        start += 1
        
```

#### 3) itertools

이터러블로 작업하면 코드가 파이썬 자체와 더 잘 어울린다. 이터레이션이 언어의 중요한 컴포넌트이기 때문이다. itertools 모듈을 사용하면 그 기능을 온전히
활용할 수 있다.

#### 4) 이터레이터를 사용한 코드 간소화

itertools 모듈을 통해 이터러블 객체를 간단하게 만들 수 있다.

**여러번 반복하기**
```python
import itertools
from statistics import median


def process_purchases(purchases):
    min_, max_, avg = itertools.tee(purchases, 3)
    return min(min_), max(max_), median(avg)


```

**중첩 루프**
```python
def _iterate_array2d(array2d):
    for i, row in enumerate(array2d):
        for j, cell in enumerate(row):
            yield (i, j), cell


def search_nested(array, desired_value):
    try:
        coord = next(
            coord for (coord, cell) in _iterate_array2d(array)
            if cell == desired_value
        )
    except StopIteration:
        raise ValueError(f"{desired_value} not found")
    
    return coord 
```


### 파이썬의 이터레이터 패턴

파이썬의 반복은 제너레이터 이상의 것으로 훌륭한 이터러블 객체를 만들게 되면 보다 효율적이고 컴팩트하고 가독성이 높은 코드를 작성할 수 있게 된다. 이터레이터는
__ iter __와 __ next __ 매직 메서드를 구현한 객체이다. __ iter __를 구현하면 이터러블 객체가 되는 것이고, __ next __를 구현하면 이터레이터
객체가 된다.

#### 이터레이션 인터페이스

이터러블인 반복할 수 있는 어떤 것으로 실제 반복을 할 때는 이터레이터를 사용한다. __ iter __ 매직 메서드를 통해 이터레이터를 반환하고, __ next __
매직 메서드를 통해 반복 로직을 구현하는 것이다. 


| 파이썬 개념          | 매직 메서드               | 비고                                                                                                             |
|-----------------|----------------------|----------------------------------------------------------------------------------------------------------------|
| 이터러블(iterable)  | __ iter __           | 이터레이터와 함께 반복 로직을 만든다. 이것을 구현한 객체는 for .. in .. 구문에서 사용할 수 있다.                                                  |
| 이터레이터(iterator) | __ next __           | 한 번에 하나씩 값을 생산하는 로직을 정의한다. 더 이상 생산할 값이 없을 경우는 StopIteration 예외를 발생시킨다.<br/>내장 next() 함수를 사용해 하나씩 값을 읽어 올 수 있다. |


#### 이터러블이 가능한 시퀀스 객체

__ iter __ 매직 메서드를 구현한 객체는 for 루프에서 사용할 수 있다. 파이썬이 for 루프를 만나면 객체가 __ iter __를 구현했는지 확인하고 있으면
그것을 사용하고 없으면 다른 대비 옵션을 가동한다.

객체가 시퀀스인 경우(__ get_item __과 __ len __ 매직 메서드를 구현한 경우)도 반복 가능하다. 이 경우엔 IndexError 예외가 발생할 때까지 순서대로
값을 제공한다.

하지만 객체를 시퀀스로 만들면 반복이 가능하지만, 기본적으로 반복을 위한 객체를 디자인할 때는 __ iter __ 매직 메서드를 구현하여 정식 이터러블 객체를
만들어야 한다.

---

## 3. 코루틴

제너레이터는 반복 가능한 객체로 next() 함수를 통해 다음 요소로 반복 또는 이동이 가능하다. 뿐만 아니라 제너레이터를 코루틴으로도 활용할 수 있다.

### 제너레이터 인터페이스의 메서드

#### 1) close()

이 메서드를 호출하면 GeneratorExit 예외가 발생한다. 이 예외를 따로 처리하지 않으면 제너레이터가 더 이상 값을 생성하지 않으며 반복이 중지된다.
이 예외는 종료 상태를 지정하는데 사용된다. 코루틴이 자원 관리를 하는 경우 코루틴이 보유한 모든 자원을 해제할 수 있다. 일반적으로 컨텍스트 관리자를 사용하거나
finally 블록에 코드를 배치하는 것과 비슷하지만 이 예외를 사용하면 보다 명확하게 처리할 수 있다. 

#### 2) throw()

이 메서드는 현재 제너레이터가 중단된 위치에서 예외를 던진다. 제너레이터가 예외를 처리했으면 해당 except절에 있는 코드가 호출되고, 예외를 처리하지 않았으면
예외가 호출자에게 전파된다. 

#### 3) send(value)

send() 함수는 제너레이터로 파라미터를 전달하는 역할을 한다. 

```python
def stream_db_records(db_handler):
    retrieved_data = None
    previous_page_size = 10
    
    try:
        while True:
            page_size = yield retrieved_data
            
            if page_size is None:
                page_size = previous_page_size
            
            previous_page_size = page_size
            
            retrieved_data = db_handler.read_n_records(page_size)
    
    except GeneratorExit:
        db_handler.close()
```

send() 함수를 통해 파라미터를 전달하면 yield 키워드가 붙어있는 변수에 할당된다. yield 키워드는 두 가지 일을 한다. 하나는 호출자에게 값을 보내고 그곳에
멈추는 것과 호출자로부터 send() 함수를 통해 전달된 값을 받는 것이다. 제너레이터는 yield 키워드까지 도달하려면 next() 함수를 한번은 호출해야 하므로
next() 함수를 호출하지 않고 send() 함수를 호출하게 되면 예외가 발생한다. 




