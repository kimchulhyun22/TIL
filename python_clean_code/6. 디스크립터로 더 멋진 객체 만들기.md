# 6. 디스크립터로 더 멋진 객체 만들기

---

디스크립터는 파이썬의 객체지향 수준을 한 단계 더 끌어올려주는 혁신적인 기능으로 이 기능을 잘 활용하면 보다 견고하고 재사용성이 높은 추상화를 할 수 있다.



## 1. 디스크립터 개요

---

### 1) 디스크립터 메커니즘

디스크립터의 동작방식은 복잡하지 않지만 세부 구현 시의 주의사항이 많다. 디스크립터를 구현하려면 최소 두 개의 클래스가 필요하다.



####  디스크립터를 구현하기 위한 클래스

- 클라이언트 클래스 : 디스크립터 구현의 기능을 활용할 도메인 모델로서 솔루션을 위해 생성한 일반적인 추상화 객체
- 디스크립터 클래스 : 디스크립터 로직의 구현체

디스크립터는 단지 디스크립터 프로토콜을 구현한 클래스의 인스턴스이다. 이 클래스는 다음 매직 메서드 중에 최소 한 개 이상을 포함해야 한다.

- \__get\__
- \__set\__
- \__delete\__
- \__set_name\__

**네이밍 컨벤션**

| 이름              | 의미                                                                    |
|-----------------|-----------------------------------------------------------------------|
| ClientClass     | 디스크립터 구현체의 기능을 활용할 도메인 추상화 객체<br/>디스크립터의 클라이언트이고 클래스 속성으로 디스크립터를 갖는다. |
| DescriptorClass | 디스크립터 클래스 <br/> 디스크립터 프로토콜을 따르는 매직 메서드를 구현해야만 한다.                     |
| client          | ClientClass의 인스턴스                                                     |
| descriptor      | DescriptorClass의 인스턴스                                                 |


명심해야 할 중요한 사실은 디스크립터 프로토콜이 동작하려면 디스크립터 객체가 클래스 속성으로 정의되어야 한다는 것이다. 이 객체를 인스턴스 속성으로 생성하면
동작하지 않으므로 init 메서드가 아니라 클래스 본문에 있어야 한다. 

```python
class DescriptorClass:
    def __get__(self, instance, owner):
        if instance is None:
            return self

        print("Call: {}.__get__({}, xx{})".format(self.__class__.__name__, instance, owner))
        return instance

class ClientClass:
    descriptor = DescriptorClass()


client = ClientClass()
print(client.descriptor)
```
디스크립터를 사용하면 완전히 새롭게 프로그램의 제어 흐름을 변경할 수 있다. 이 도구를 사용해 \__get\__ 메서드 뒤쪽으로 모든 종류의 논리를 추상화할 수 있으
며 클라이언트에게 내용을 숨긴 채로 모든 유형의 변환을 투명하게 실행할 수 있다. 이것은 새로운 레벨의 캡슐화이다.

---

### 2) 디스크립터 프로토콜의 메서드 탐색

디스크립터는 단지 객체이기 때문에 이러한 메서드들은 객체 자신을 나타내는 self를 첫 번째 파라미터로 사용한다. 디스크립터 프로토콜의 각 메서드에 사용되는
파라미터와 사용 방법에 대해서 알아보자.

---

#### \__get\__(self, instance, owner)

- instance
    - 디스크립터를 호출한 객체
    - 디스크립터가 행동을 취하려는 객체
- owner
    - 해당 객체의 클래스
    - 인스턴스의 클래스
  
```python
class DescriptorClass:
    def __get__(self, instance, owner):
        if instance is None:
            return self

        print("Call: {}.__get__({}, xx{})".format(self.__class__.__name__, instance, owner))
        return instance

class ClientClass:
    descriptor = DescriptorClass()


print(ClientClass.descriptor)
```

위의 코드처럼 객체를 생성한 것이 아니라 클래스 속성으로서 디스크립터 객체에 접근하면 instance는 None이기 때문에 owner에 해당하는 클래스를 알 수 없으므로
instance와 owner가 구분되어 있다. 일반적으로 위와 같이 instance가 None인 경우는 단순히 디스크립터 객체를 반환한다.

---

#### \__set\__(self, instance, value)

이 메서드는 디스크립터에 값을 할당하려고 할 때 호출된다. 다음과 같이 __ set __() 메서드를 구현한 디스크립터에 대해서만 활성화된다.

- instance
    - 디스크립터를 호출한 객체
- value
    - 데이터 변경 값

```python
class Validation:

    def __init__(self, validation_function, error_msgs: str):
        self.validation_function = validation_function
        self.error_msgs = error_msgs

    def __call__(self, value):
        if not self.validation_function(value):
            raise ValueError(f"{value!r} {self.error_msgs}")


class Field:
    def __init__(self, *validations):
        self._name = None
        self.validations = validations

    def __set_name__(self, owner, name):
        self._name = name

    def __get__(self, instance, owner):
        if instance is None:
            return self

        return instance.__dict__[self._name]

    def validate(self, value):
        for validation in self.validations:
            validation(value)

    def __set__(self, instance, value):
        self.validate(value)
        instance.__dict__[self._name] = value


class ClientClass:
    descriptor = Field(
        Validation(lambda x: isinstance(x, (int, float)), "는 숫자가 아님"),
        Validation(lambda x: x >= 0, "는 0보다 작음")
    )


client = ClientClass()
client.descriptor = 42
print(client.descriptor)

client.descriptor = "42"
print(client.descriptor)
```

프로퍼티 자리에 놓일 수 있는 것은 디스크립터로 추상화할 수 있으며 여러 번 재사용할 수 있다. 위의 예제에서는 __ set __ 메서드가 @property.setter를
대신한다.

---
 
#### \__delete\__(self, instance)
- instance
    - 디스크립터를 호출한 객체

```python
class ProtectedAttribute:
    def __init__(self, requires_role=None):
        self.permission_required = requires_role
        self._name = None

    def __set_name__(self, owner, name):
        self._name = name

    def __set__(self, user, value):
        if value is None:
            raise ValueError(f"{self._name}를 None으로 설정할 수 없음")

        user.__dict__[self._name] = value

    def __delete__(self, user):
        if self.permission_required in user.permissions:
            user.__dict__[self._name] = None

        else:
            raise ValueError(
                f"{user!s} 사용자는 {self.permission_required} 권한이 없음"
            )


class User:
    email = ProtectedAttribute(requires_role="admin")

    def __init__(self, username: str, email: str, permission_list: list = None):
        self.username = username
        self.email = email
        self.permissions = permission_list or []

    def __str__(self):
        return self.username


admin = User("root", "root@d.com", ["admin"])
user = User("user", "user1@d.com", ["email", "helpdesk"])

print(admin.email)

del admin.email

print(admin.email is None)

print(user.email)

user.email = None
```

---

#### \__set_name\__(self, owner, name)

일반적으로 클래스에 디스크립터 객체를 만들 때는 디스크립터가 처리하려는 속성의 이름을 알아야 한다. 

```python
class DescriptorWithName:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, value):
        if instance is None:
            return self

        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        print("__set_name__ = ", name)
        self.name = name


class ClientClass:
    descriptor = DescriptorWithName("descriptor")
    
```
---



