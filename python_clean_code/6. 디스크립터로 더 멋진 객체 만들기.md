# 6. 디스크립터로 더 멋진 객체 만들기

디스크립터는 파이썬의 객체지향 수준을 한 단계 더 끌어올려주는 혁신적인 기능으로 이 기능을 잘 활용하면 보다 견고하고 재사용성이 높은 추상화를 할 수 있다.



## 1. 디스크립터 개요



### 1) 디스크립터 메커니즘

디스크립터의 동작방식은 복잡하지 않지만 세부 구현 시의 주의사항이 많다. 디스크립터를 구현하려면 최소 두 개의 클래스가 필요하다.



####  디스크립터를 구현하기 위한 클래스

- 클라이언트 클래스 : 디스크립터 구현의 기능을 활용할 도메인 모델로서 솔루션을 위해 생성한 일반적인 추상화 객체
- 디스크립터 클래스 : 디스크립터 로직의 구현체

디스크립터는 단지 디스크립터 프로토콜을 구현한 클래스의 인스턴스이다. 이 클래스는 다음 매직 메서드 중에 최소 한 개 이상을 포함해야 한다.

- \__get\__
- \__set\__
- \__delete\__
- \__set_name\__

**네이밍 컨벤션**

| 이름              | 의미                                                                    |
|-----------------|-----------------------------------------------------------------------|
| ClientClass     | 디스크립터 구현체의 기능을 활용할 도메인 추상화 객체<br/>디스크립터의 클라이언트이고 클래스 속성으로 디스크립터를 갖는다. |
| DescriptorClass | 디스크립터 클래스 <br/> 디스크립터 프로토콜을 따르는 매직 메서드를 구현해야만 한다.                     |
| client          | ClientClass의 인스턴스                                                     |
| descriptor      | DescriptorClass의 인스턴스                                                 |


명심해야 할 중요한 사실은 디스크립터 프로토콜이 동작하려면 디스크립터 객체가 클래스 속성으로 정의되어야 한다는 것이다. 이 객체를 인스턴스 속성으로 생성하면
동작하지 않으므로 init 메서드가 아니라 클래스 본문에 있어야 한다. 

```python
class DescriptorClass:
    def __get__(self, instance, owner):
        if instance is None:
            return self

        print("Call: {}.__get__({}, xx{})".format(self.__class__.__name__, instance, owner))
        return instance

class ClientClass:
    descriptor = DescriptorClass()


client = ClientClass()
print(client.descriptor)
```
디스크립터를 사용하면 완전히 새롭게 프로그램의 제어 흐름을 변경할 수 있다. 이 도구를 사용해 \__get\__ 메서드 뒤쪽으로 모든 종류의 논리를 추상화할 수 있으
며 클라이언트에게 내용을 숨긴 채로 모든 유형의 변환을 투명하게 실행할 수 있다. 이것은 새로운 레벨의 캡슐화이다.

---

### 2) 디스크립터 프로토콜의 메서드 탐색

디스크립터는 단지 객체이기 때문에 이러한 메서드들은 객체 자신을 나타내는 self를 첫 번째 파라미터로 사용한다. 디스크립터 프로토콜의 각 메서드에 사용되는
파라미터와 사용 방법에 대해서 알아보자.

---

#### \__get\__(self, instance, owner)

- instance
    - 디스크립터를 호출한 객체
    - 디스크립터가 행동을 취하려는 객체
- owner
    - 해당 객체의 클래스
    - 인스턴스의 클래스
  
```python
class DescriptorClass:
    def __get__(self, instance, owner):
        if instance is None:
            return self

        print("Call: {}.__get__({}, xx{})".format(self.__class__.__name__, instance, owner))
        return instance

class ClientClass:
    descriptor = DescriptorClass()


print(ClientClass.descriptor)
```

위의 코드처럼 객체를 생성한 것이 아니라 클래스 속성으로서 디스크립터 객체에 접근하면 instance는 None이기 때문에 owner에 해당하는 클래스를 알 수 없으므로
instance와 owner가 구분되어 있다. 일반적으로 위와 같이 instance가 None인 경우는 단순히 디스크립터 객체를 반환한다.

---

#### \__set\__(self, instance, value)

이 메서드는 디스크립터에 값을 할당하려고 할 때 호출된다. 다음과 같이 __ set __() 메서드를 구현한 디스크립터에 대해서만 활성화된다.

- instance
    - 디스크립터를 호출한 객체
- value
    - 데이터 변경 값

```python
class Validation:

    def __init__(self, validation_function, error_msgs: str):
        self.validation_function = validation_function
        self.error_msgs = error_msgs

    def __call__(self, value):
        if not self.validation_function(value):
            raise ValueError(f"{value!r} {self.error_msgs}")


class Field:
    def __init__(self, *validations):
        self._name = None
        self.validations = validations

    def __set_name__(self, owner, name):
        self._name = name

    def __get__(self, instance, owner):
        if instance is None:
            return self

        return instance.__dict__[self._name]

    def validate(self, value):
        for validation in self.validations:
            validation(value)

    def __set__(self, instance, value):
        self.validate(value)
        instance.__dict__[self._name] = value


class ClientClass:
    descriptor = Field(
        Validation(lambda x: isinstance(x, (int, float)), "는 숫자가 아님"),
        Validation(lambda x: x >= 0, "는 0보다 작음")
    )


client = ClientClass()
client.descriptor = 42
print(client.descriptor)

client.descriptor = "42"
print(client.descriptor)
```

프로퍼티 자리에 놓일 수 있는 것은 디스크립터로 추상화할 수 있으며 여러 번 재사용할 수 있다. 위의 예제에서는 __ set __ 메서드가 @property.setter를
대신한다.

---
 
#### \__delete\__(self, instance)
- instance
    - 디스크립터를 호출한 객체

```python
class ProtectedAttribute:
    def __init__(self, requires_role=None):
        self.permission_required = requires_role
        self._name = None

    def __set_name__(self, owner, name):
        self._name = name

    def __set__(self, user, value):
        if value is None:
            raise ValueError(f"{self._name}를 None으로 설정할 수 없음")

        user.__dict__[self._name] = value

    def __delete__(self, user):
        if self.permission_required in user.permissions:
            user.__dict__[self._name] = None

        else:
            raise ValueError(
                f"{user!s} 사용자는 {self.permission_required} 권한이 없음"
            )


class User:
    email = ProtectedAttribute(requires_role="admin")

    def __init__(self, username: str, email: str, permission_list: list = None):
        self.username = username
        self.email = email
        self.permissions = permission_list or []

    def __str__(self):
        return self.username


admin = User("root", "root@d.com", ["admin"])
user = User("user", "user1@d.com", ["email", "helpdesk"])

print(admin.email)

del admin.email

print(admin.email is None)

print(user.email)

user.email = None
```

---

#### \__set_name\__(self, owner, name)

일반적으로 클래스에 디스크립터 객체를 만들 때는 디스크립터가 처리하려는 속성의 이름을 알아야 한다. 

```python
class DescriptorWithName:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, value):
        if instance is None:
            return self

        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        print("__set_name__ = ", name)
        self.name = name


class ClientClass:
    descriptor = DescriptorWithName("descriptor")
    
```

---

## 2. 디스크립터의 유형

디스크립터는 작동방식에 따라 구분되는데 이 구분을 이해하는 것은 디스크립터를 효과적으로 사용하는데 중요한 역할을 하고, 런타임 시 경고 또는 일반적인 오류를
피하는데 도움이 된다.

- 데이터 디스크립터 : \__set\__ 이나 \__delete\__ 메서드를 구현한 경우
- 비데이터 디스크립터 : \__get\__만을 구현한 경우

객체의 속성을 결정할 때 데이터 디스크립터가 객체의 사전보다 우선적으로 적용되지만 비데이터 디스크립터는 객체의 사전에 디스크립터와 동일한 이름의 키가 있으면
객체의 사전 값이 적용되고 디스크립터는 절대 호출되지 않을 것이다. 반대로 데이터 디스크립터는 동일한 이름을 갖는 키가 사전에 존재하더라도 디스크립터 자체가
항상 먼저 호출되기 때문에 객체의 키 값은 절대 사용되지 않을 것이다.

### 1) 비데이터 디스크립터

```python
class NoneDataDescriptor:
    def __get__(self, instance, owner):
        if instance is None:
            return self

        return 42


class ClientClass:
    descriptor = NoneDataDescriptor()


client = ClientClass()

# 객체 사전에 등록된 키가 없어 디스크립터가 호출된다
print(vars(client))
print(client.descriptor)

# 객체 사전 등록
client.descriptor = 43

print(vars(client))
print(client.descriptor)

# 객체 사전 삭제
del client.descriptor

print(vars(client))
print(client.descriptor)
```

ClientClass 인스턴스를 통해 descriptor 속성을 조회하면 client.\__dict\__에서 descriptor라는 이름의 키를 찾기 못하고 마침내 클래스에서
디스크립터를 찾게 된다. 따라서 객체 사전에 등록된 키가 없으면 디스크립터의 \__get\__메서드의 결과가 반환되는 것이다.

---

### 2) 데이터 디스크립터

```python
class DataDescriptor:
    def __get__(self, instance, owner):
        if instance is None:
            return self

        return 42

    def __set__(self, instance, value):
        print("{}.descriptor를 {} 값으로 설정".format(instance, value))
        instance.__dict__["descriptor"] = value


class ClientClass:
    descriptor = DataDescriptor()


client = ClientClass()
print(vars(client))
print(client.descriptor)

client.descriptor = 99
print(vars(client))
print(client.descriptor)
```

데이터 디스크립터에서 속성을 조회하면 객체의 __ dict __에서 조회하는 대신 클래스의 디스크립터를 먼저 조회한다. 따라서 속성 삭제는 동작하지 않는다.
삭제가 동작하지 않는 이유는 del을 호출하면 속성을 지우는 것이 아니라 디스크립터의 __ delete __ 메서드를 호출하게 되는데 위의 예제에서는 구현되어 있지
않기 때문이다. 

---

## 3. 디스크립터 실전

### 1) 디스크립터를 사용한 애플리케이션

중복 코드를 디스크립터로 추상화하게 되면 클라이언트의 코드가 굉장히 많이 줄어들 수 있다. 

#### 디스크립터를 사용하지 않은 예
```python
class Traveller:
    def __init__(self, name, current_city):
        self.name = name
        self._current_city = current_city
        self._cities_visited = [current_city]
    
    @property
    def current_city(self):
        return self._current_city
        
    @current_city.setter
    def current_city(self, new_city):
        if new_city != self._current_city:
            self._cities_visited.append(new_city)
            self._current_city = new_city
    
    @property
    def cities_visited(self):
        return self._cities_visited

```

위의 기능만 제공한다면 프로퍼티를 사용해서 충분히 깔끔하게 구현할 수 있다. 하지만 애플리케이션의 여러 곳에서 똑같은 로직을 사용한다면 코드를 반복하거나
데코레이터, 프로퍼티 빌더 또는 디스크립터 같은 것을 만들어야 한다. 

#### 이상적인 구현방법

```python
class HistoryTracedAttribute:
    def __init__(self, trace_attribute_name) -> None:
        self.trace_attribute_name = trace_attribute_name
        self._name = None

    def __set_name__(self, owner, name):
        self._name = name

    def __get__(self, instance, owner):
        if instance is None:
            return self

        return instance.__dict__[self._name]

    def __set__(self, instance, value):
        self._track_change_in_value_for_instance(instance, value)
        instance.__dict__[self._name] = value

    def _track_change_in_value_for_instance(self, instance, value):
        self._set_default(instance)
        if self._needs_to_track_change(instance, value):
            instance.__dict__[self.trace_attribute_name].append(value)

    def _needs_to_track_change(self, instance, value):
        try:
            current_value = instance.__dict__[self._name]

        except KeyError:
            return True

        return value != current_value

    def _set_default(self, instance):
        instance.__dict__.setdefault(self.trace_attribute_name)


class Traveller:
    current_city = HistoryTracedAttribute("cities_visited")

    def __init__(self, name, current_city):
        self.name = name
        self.current_city = current_city
```

위의 코드는 디스크립터의 코드가 복잡하지만 클라이언트 클래스의 코드는 상당히 간단해졌다. 따라서 이 디스크립터를 여러 번 사용한다면 충분한 가치가 있다.
또 디스크립터가 비즈니스 로직을 포함하지 않고 완전히 다른 클래스에서 적용하여도 같은 효과를 내면 진정 파이썬스러운 디스크립터가 되는 것이다. 따라서
디스크립터는 비즈니스 로직의 구현보다는 라이브러리, 프레임워크 또는 내부 API를 정의하는데 적합하다.

---

### 2) 다른 형태의 디스크립터

디스크립터의 특성과 관련된 문제를 먼저 이해하자.

#### 전역 상태 공유 이슈

디스크립터는 클래스 속성으로 설정해야 한다. 이러한 클래스 속성의 문제점은 이들이 해당 클래스의 모든 인스턴스에서 공유된다는 것이다. 따라서 디스크립터 객체에
데이터를 보관하면 모든 객체가 동일한 값에 접근할 수 있다. 따라서 디스크립터는 각 인스턴스의 값을 보관했다가 반환해야 한다. 
이것이 각 인스턴스의 __ dict __ 사전에 값을 설정하고 검색하는 이유다.

#### 객체의 사전에 접근하기

항상 인스턴스의 __ dict __ 속성에서 데이터를 저장하고 반환한다. 

#### 약한 참조 사용

__ dict __를 사용하지 않으려면 디스크립터 객체가 직접 내부 매핑을 통해 각 인스턴스의 값을 보관하고 반환하는 것이다. 이런 방법을 사용할 때 사전을 사용하면
클라이언트 클래스는 디스크립터에 대한 참조를 가지며 디스크립터는 디스크립터를 사용하는 객체에 대한 참조를 가지므로 순환 종속성이 생겨 결과적으로 결코 가비지
컬렉션이 되지 않는다. 따라서 사전은 weakref 모듈에 정의된 것처럼 약한 키가 되어야 한다.

```python
from weakref import WeakKeyDictionary


class DescriptorClass:
    def __init__(self, initial_value):
        self.value = initial_value
        self.mapping = WeakKeyDictionary()
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        
        return self.mapping.get(instance, self.value)
    
    def __set__(self, instance, value):
        self.mapping[instance] = value
```

하지만 고려야해야할 사항이 있다.

1. 인스턴스 객체는 더 이상 속성을 보유하지 않는다. 대신 디스크립터가 속성을 보유한다.
2. 객체는 __ hash __ 메서드를 구현하여 해시가 가능해야 한다. 만약 해시가 가능하지 않으면 WeakKeyDictionary에 매핑할 수가 없다.

결론적으로 각 인스턴의 __ dict __ 사전을 사용하는 것이 가장 좋다.

---

### 3) 디스크립터에 대한 추가 고려사항

#### 코드 재사용

디스크립터는 코드 중복을 피하기 위한 일반적인 도구이자 강력한 추상화 도구이다. 디스크립터가 필요한 곳을 찾는 가장 좋은 방법은 프로퍼티가 필요한 구조가
반복되는 경우를 찾는 것이다. 

프로퍼티는 get, set, delete 작업을 정의하여 디스크립터 프로토콜을 모두 구현한 디스크립터이다. 따라서 디스크립터는 프로퍼티보다 훨씬 복잡한 작업에
사용될 수 있다. 디스크립터는 데코레이터와 마찬가지로 같읕 코드가 3회 이상 필요할 경우에 재사용성을 고려하는 것이 좋다. 뿐만 아니라 클라이언트가 사용하게 되는
내부 API에 대해서는 디스크립터를 사용하는 것이 좋다. 단, 비지니스 로직을 디스크립터의 코드에 포함하면 안되고 단지 비즈니스 로직에서 사용할 새로운 객체나
데이터 구조만 정의해야 한다.

#### 클래스 데코레이터 피하기

