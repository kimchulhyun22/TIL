# 9. 일반적인 디자인 패턴

디자인 패턴은 개발 중에 자주 발생하는 일반적인 문제들을 어떻게 추상화하여 해결할 수 있는지 다루고 이것들을 적절히 사용하여 문제들을 
쉽게 해결할 수 있도록 한다.

---

## 1. 파이썬에 디자인 패턴 적용 시 고려사항

객체 지향 디자인 패턴은 다양한 시나리오에서 해결책의 하나로 제시되는 모델 중 하나이다. 하지만 파이썬은 이미 일부 디자인 패턴을 내부적으로 구현하고 있기
때문에 실제로 필요하지 않은 패턴들이 있다. 파이썬에서 클린 코드를 달성하기 위한 중요한 목표는 어떤 패턴들이 있고 어떻게 구현할 수 있는지를 파악하는 것이다.
이미 파이썬에서 추상화한 패턴 중 일부를 인지하고 이를 활용할 수 있는 방법을 터득하는 것이다. 모든 패턴이 똑같이 자주 사용되는 것도 아니고 유용한 것도 아니다.
따라서 언어의 특성에 초점을 맞추어 실용적인 방법을 터득해야 하낟.

---

## 2. 실전 속의 디자인 패턴

디자인 패턴은 생성, 구조, 행동 패턴 중의 하나로 분류되고 이것들의 확장 버전이나 변형 버전의 패턴도 존재한다. 하지만 모든 것들을 자세히 살펴볼 필요는 없다.

첫째, 일부 패턴은 파이썬 내부에서 자체적으로 구현되어 있으므로 보이지 않은 채로도 적절히 적용될 수 있다.

둘째, 모든 패턴이 똑같이 일반적인 것은 아니다.

따라서 강제로 디자인 패턴을 적용할 필요는 없고 패턴이 출현할 때까지는 솔루션을 진화시키고 리팩토링하고 개선해야만 한다. 따라서 디자인 패턴은 발명되는 것이
아니라 발견되는 것이다. 코드에 반복적으로 같은 내용이 출현할 때 일반적이고 추상화된 클래스, 객체 또는 컴포넌트의 패턴이 발견되는 것이다.

---

## 1) 생성 패턴

소프트웨어 공학에서 생성 패턴은 객체를 인스턴스화 할 떄의 복잡성을 최대한 추상화하기 위한 것이다. 객체 초기화를 위한 파라미터를 결정하거나 초기화에 필요한
관련 객체를 준비하는 것 등의 모든 관련 작업을 단순화하려는 것이다. 이를 통해 더 간단한 인터페이스를 제공할 수 있고 사용자는 보다 안전하게 객체를
생성할 수 있다.

### (1) 팩토리

파이썬의 핵심 기능 중 하나는 모든 것이 객체라는 것이며 모두 똑같이 취급될 수 있다는 것이다. 즉, 클래스, 함수 또는 사용자 정의 객체 각각의 역할이 특별히
구분되어 있지 않다. 이들은 모두 파라미터나 할당 등에 사용될 수 있다. 이러한 이유로 파이썬에서는 팩토리 패턴이 별로 필요하지 않다.

### (2) 싱글턴과 공유 상태

일반적으로 싱글턴 패턴은 많은 문제가 있기 때문에 필요하지 않거나 나쁜 선택이다. 객체 지향 소프트웨어를 위한 전역 변수의 한 형태이고 단위 테스트가 어렵다. 
어떤 객체에 의해서 언제든지 수정될 수 있기 때문에 부작용이 크다.

파이썬에서 싱글턴을 사용하기 위한 방법은 모듈을 사용하는 것이다. 모둘에 객체를 생성하고, 모듈을 임포트한 모든 곳에서 사용할 수 있다. 파이썬에서 모듈은 이미
싱글턴이라는 것을 의미한다. 즉, 여러 번 임포트하더라도 sys.modules에 로딩되는 것은 항상 한 개다.

**공유상태**

객체가 어떻게 호출, 생성 또는 초기화 되는지에 상관없이 하나의 인스턴스만 갖는 싱글턴을 사용하는 것보다는 여러 인스턴스에서 사용할 수 있도록 데이터를 
복제하는 것이 좋다. *모노 스테이트*의 주요 개념은 싱글턴인지 아닌지에 상관없이 일반 객체처럼 많은 인스턴스를 만들 수 있어야 한다는 것이다.

Git 저장소에서 최신 태그의 코드를 가져오는 객체가 있다고 가정해보자. 이 객체의 인스턴스는 여러 개 있을 수 있고 어떤 클라이언트에서든 코드 가져오기 요청을
하면 tag라는 공통의 속성을 참조할 것이다. tag는 언제든지 새 버전으로 업데이트될 수 있고 fetch 요청을 하면 기존의 인스턴스뿐 아니라 새로운 인스턴스에서도
해당 버전을 참조해야 한다.

```python
class SharedAttribute:
    def __init__(self, initial_value=None):
        self.value = initial_value
        self._name = None
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        if self.value is None:
            raise AttributeError(f"{self._name} was never set")
        return self.value
    
    def __set__(self, instance, value):
        self.value = value
    
    def __set_name__(self, owner, name):
        self._name = name


class GitFetcher:
    current_tag = SharedAttribute()
    current_branch = SharedAttribute()
    
    def __init__(self, tag, branch=None):
        self.current_tag = tag
        self.current_branch = branch
    
    def pull(self):
        print("%s에서 풀", self.current_tag)
        return self.current_tag
```

위와 같이 디스크립터를 사용하여 문제를 해결하면 좀 더 많은 코드가 필요하지만 구체적인 책임을 캡슐화하고 코드를 분리하여 각각이 응집력을 갖게 되므로
단일 책임 원칙을 준수할 수 있게 된다.

**borg 패턴**

꼭 싱글턴을 사용해야 하는 경우라면 모노 스테이트 패턴으로 동작하는 borg 패턴을 사용하는 것이 더 좋다. 주요 개념은 같은 클래스의 모든 인스턴스가 모든 속성을
복제하는 객체를 만드는 것이다. 

**빌더**

빌더 패턴은 객체의 복잡한 초기화를 추상화하는 패턴이다. 이 패턴의 큰 개념은 필요로 하는 모든 객체를 직접 생성해주는 하나의 복잡한 객체를 만들어야 한다는
것이다. 사용자가 필요로 하는 모든 보조 객체를 직접 생성하여 메인 객체에 전달하는 것이 아니라, 한 번에 모든 것을 처리해주는 추상화를 해야 한다는 것이다.
빌더 객체는 필요한 모든 것들을 어떻게 생성하고 연결하는지를 알고 있다. 빌더 객체는 클래스 메서드와 같은 사용자 인터페이스를 제공하며, 사용자는 최종 객체에
대한 모든 정보를 해당 인터페이스에 파라미터로 전달하면 된다.

---

## 2) 구조 패턴

구조 패턴은 인터페이스를 복잡하게 하지 않으면서도 기능을 확장하여 더 강력한 인터페이스 또는 객체를 만들어야 하는 상황에 유용하다. 이러한 패턴의 가장 큰 장점은
향상된 기능을 깔끔하게 구현할 수 있다는 것이다. 즉 여러 개의 객체를 조합하거나 작고 응집력 높은 인터페이스들을 조합하기만 하면 된다.

### (1) 어댑터 패턴

wrapper라고도 하는 이 패턴은 호환되지 않은 두 개 이상의 객체에 대한 인터페이스를 동시에 사용할 수 있게 한다. 개발을 하다보면 일반적으로 다형성을 가진
여러 클래스나 모델을 사용하게 된다. 하지만 기존 인터페이스와 호환이 되지 않을 뿐만 아니라 수정 권한이 없는 경우도 있을 것이다. 따라서 이러한 새로운 객체를
직접 사용하는 대신에 해당 객체를 수용할 수 있는 새로운 인터페이스를 개발할 필요가 있다. 

예를 들어 fetch 메서드를 가지는 여러 객체가 있다고 가정해보자. 새로운 추가된 객체에 fetch 메서드는 없지만 다른 이름의 메서드가 있는 경우는 사용하려는
클래스를 상속받는 클래스를 만들고 그 메서드를 래핑하는 새로운 별칭의 fetch 메서드를 추가하는 것이다.

```python
from _adapter_base import UsernameLookup

class UserSource(UsernameLookup):
    def fetch(self, user_id, username):
        user_namespace = self._adapter_arguments(user_id, username)
        return self.search(user_namespace)
    
    @staticmethod
    def _adapter_arguments(user_id, username):
        return f"{user_id}:{username}"
```

상속은 얼마나 많은 외부 라이브러리를 가져올지 정확히 알기 어렵고 강한 결합을 만들고 융통성을 떨어뜨린다. 따라서 **is a** 관계가 아니면 사용하지 않는 것이
좋다. 따라서 컴포지션을 사용하는 것이 더 좋다.

### (2) 컴포지트

프로그램에서 사용하는 객체는 내부적으로 또 다른 여러 객체를 사용해서 작업하게 된다. 잘 정의된 로직을 가진 기본 객체도 있고, 이러한 기본 객체들을 묶어서 
사용하는 컨테이너 객체도 있다. 개체는 구조화된 트리 형태이다. 기본 객체는 리프 노드이고 컨테이너 객체는 중간 노드라 볼 수 있다. 클라이언트는 이 중에 아무거나
호출하여 결과를 얻고자 할 것이다. 컴포지트 객체도 클라이언트처럼 동작한다. 리프 노드인지 중간 노드인지에 상관없이 해당 요청을 관련 노드가 처리할 수 있을 때까지
계속 전달한다.

```python
from typing import Union, Iterable


class Product:
    def __init__(self, name, price):
        self._name = name
        self._price = price
    
    @property
    def price(self):
        return self._price


class ProductBundle:
    def __init__(self, name, perc_discount, 
                 *products: Iterable[Union[Product, "ProductBundle"]]):
        self._name = name
        self._perc_discount = perc_discount
        self._products = products
    
    @property
    def price(self):
        total = sum(p.price for p in self._products)
        return total * (1 - self._perc_discount)
```

### (3) 데코레이터

데코레이터 패턴을 사용하면 상속을 하지 않고도 객체의 기능을 동적으로 확장할 수 있다.

```python
class DictQuery:
    def __init__(self, **kwargs):
        self._raw_query = kwargs

    def render(self) -> dict:
        return self._raw_query


class QueryEnhancer:
    def __init__(self, query: DictQuery):
        self.decorated = query

    def render(self):
        return self.decorated.render()


class RemoveEmpty(QueryEnhancer):
    def render(self):
        original = super().render()
        return {k: v for k, v in original.items() if v}


class CaseInsensitive(QueryEnhancer):
    def render(self):
        original = super().render()
        return {k: v.lower() for k, v in original.items()}


original = DictQuery(key="value", empty="", none=None, upper="UPPERCASE", title="Title")

print(original.render())

new_query = CaseInsensitive(RemoveEmpty(original))

print(new_query.render())
```

### (4) 파사드

파사드 패턴은 객체 간 상호 작용을 단순화하려는 많은 상황에서 유용하다. 여러 객체가 다대다 관계를 이루며 상호작용하는 경우에 사용된다. 각각의 객체에 대한
모든 연결을 만드는 대신 파사드 역할을 하는 중간 객체를 만드는 것이다. 

파사드는 허브 또는 단일 참조점의 역할을 한다. 새로운 객체가 다른 객체에 연결하려고 할 때마다 연결해야 하는 N개의 객체에 대해 N개의 인터페이스를 만들면
복잡하기 때문에 파사드와 대화하게 하고 파사드에서 적절히 요청을 전달해주면 편리할 것이다. 외부 오브젝트의 입장에서는 파사드 내부의 모든 내용이 완전히
불투명해야 한다.

