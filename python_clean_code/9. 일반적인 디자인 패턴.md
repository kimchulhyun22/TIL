# 9. 일반적인 디자인 패턴

디자인 패턴은 개발 중에 자주 발생하는 일반적인 문제들을 어떻게 추상화하여 해결할 수 있는지 다루고 이것들을 적절히 사용하여 문제들을 
쉽게 해결할 수 있도록 한다.

---

## 1. 파이썬에 디자인 패턴 적용 시 고려사항

객체 지향 디자인 패턴은 다양한 시나리오에서 해결책의 하나로 제시되는 모델 중 하나이다. 하지만 파이썬은 이미 일부 디자인 패턴을 내부적으로 구현하고 있기
때문에 실제로 필요하지 않은 패턴들이 있다. 파이썬에서 클린 코드를 달성하기 위한 중요한 목표는 어떤 패턴들이 있고 어떻게 구현할 수 있는지를 파악하는 것이다.
이미 파이썬에서 추상화한 패턴 중 일부를 인지하고 이를 활용할 수 있는 방법을 터득하는 것이다. 모든 패턴이 똑같이 자주 사용되는 것도 아니고 유용한 것도 아니다.
따라서 언어의 특성에 초점을 맞추어 실용적인 방법을 터득해야 하낟.

---

## 2. 실전 속의 디자인 패턴

디자인 패턴은 생성, 구조, 행동 패턴 중의 하나로 분류되고 이것들의 확장 버전이나 변형 버전의 패턴도 존재한다. 하지만 모든 것들을 자세히 살펴볼 필요는 없다.

첫째, 일부 패턴은 파이썬 내부에서 자체적으로 구현되어 있으므로 보이지 않은 채로도 적절히 적용될 수 있다.

둘째, 모든 패턴이 똑같이 일반적인 것은 아니다.

따라서 강제로 디자인 패턴을 적용할 필요는 없고 패턴이 출현할 때까지는 솔루션을 진화시키고 리팩토링하고 개선해야만 한다. 따라서 디자인 패턴은 발명되는 것이
아니라 발견되는 것이다. 코드에 반복적으로 같은 내용이 출현할 때 일반적이고 추상화된 클래스, 객체 또는 컴포넌트의 패턴이 발견되는 것이다.

---

## 1) 생성 패턴

소프트웨어 공학에서 생성 패턴은 객체를 인스턴스화 할 떄의 복잡성을 최대한 추상화하기 위한 것이다. 객체 초기화를 위한 파라미터를 결정하거나 초기화에 필요한
관련 객체를 준비하는 것 등의 모든 관련 작업을 단순화하려는 것이다. 이를 통해 더 간단한 인터페이스를 제공할 수 있고 사용자는 보다 안전하게 객체를
생성할 수 있다.

### (1) 팩토리

파이썬의 핵심 기능 중 하나는 모든 것이 객체라는 것이며 모두 똑같이 취급될 수 있다는 것이다. 즉, 클래스, 함수 또는 사용자 정의 객체 각각의 역할이 특별히
구분되어 있지 않다. 이들은 모두 파라미터나 할당 등에 사용될 수 있다. 이러한 이유로 파이썬에서는 팩토리 패턴이 별로 필요하지 않다.

### (2) 싱글턴과 공유 상태

일반적으로 싱글턴 패턴은 많은 문제가 있기 때문에 필요하지 않거나 나쁜 선택이다. 객체 지향 소프트웨어를 위한 전역 변수의 한 형태이고 단위 테스트가 어렵다. 
어떤 객체에 의해서 언제든지 수정될 수 있기 때문에 부작용이 크다.

파이썬에서 싱글턴을 사용하기 위한 방법은 모듈을 사용하는 것이다. 모둘에 객체를 생성하고, 모듈을 임포트한 모든 곳에서 사용할 수 있다. 파이썬에서 모듈은 이미
싱글턴이라는 것을 의미한다. 즉, 여러 번 임포트하더라도 sys.modules에 로딩되는 것은 항상 한 개다.

**공유상태**

객체가 어떻게 호출, 생성 또는 초기화 되는지에 상관없이 하나의 인스턴스만 갖는 싱글턴을 사용하는 것보다는 여러 인스턴스에서 사용할 수 있도록 데이터를 
복제하는 것이 좋다. *모노 스테이트*의 주요 개념은 싱글턴인지 아닌지에 상관없이 일반 객체처럼 많은 인스턴스를 만들 수 있어야 한다는 것이다.

Git 저장소에서 최신 태그의 코드를 가져오는 객체가 있다고 가정해보자. 이 객체의 인스턴스는 여러 개 있을 수 있고 어떤 클라이언트에서든 코드 가져오기 요청을
하면 tag라는 공통의 속성을 참조할 것이다. tag는 언제든지 새 버전으로 업데이트될 수 있고 fetch 요청을 하면 기존의 인스턴스뿐 아니라 새로운 인스턴스에서도
해당 버전을 참조해야 한다.

```python
class SharedAttribute:
    def __init__(self, initial_value=None):
        self.value = initial_value
        self._name = None
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        if self.value is None:
            raise AttributeError(f"{self._name} was never set")
        return self.value
    
    def __set__(self, instance, value):
        self.value = value
    
    def __set_name__(self, owner, name):
        self._name = name


class GitFetcher:
    current_tag = SharedAttribute()
    current_branch = SharedAttribute()
    
    def __init__(self, tag, branch=None):
        self.current_tag = tag
        self.current_branch = branch
    
    def pull(self):
        print("%s에서 풀", self.current_tag)
        return self.current_tag
```

위와 같이 디스크립터를 사용하여 문제를 해결하면 좀 더 많은 코드가 필요하지만 구체적인 책임을 캡슐화하고 코드를 분리하여 각각이 응집력을 갖게 되므로
단일 책임 원칙을 준수할 수 있게 된다.

**borg 패턴**

꼭 싱글턴을 사용해야 하는 경우라면 모노 스테이트 패턴으로 동작하는 borg 패턴을 사용하는 것이 더 좋다. 주요 개념은 같은 클래스의 모든 인스턴스가 모든 속성을
복제하는 객체를 만드는 것이다. 

**빌더**

빌더 패턴은 객체의 복잡한 초기화를 추상화하는 패턴이다. 이 패턴의 큰 개념은 필요로 하는 모든 객체를 직접 생성해주는 하나의 복잡한 객체를 만들어야 한다는
것이다. 사용자가 필요로 하는 모든 보조 객체를 직접 생성하여 메인 객체에 전달하는 것이 아니라, 한 번에 모든 것을 처리해주는 추상화를 해야 한다는 것이다.
빌더 객체는 필요한 모든 것들을 어떻게 생성하고 연결하는지를 알고 있다. 빌더 객체는 클래스 메서드와 같은 사용자 인터페이스를 제공하며, 사용자는 최종 객체에
대한 모든 정보를 해당 인터페이스에 파라미터로 전달하면 된다.

---

## 2) 구조 패턴

구조 패턴은 인터페이스를 복잡하게 하지 않으면서도 기능을 확장하여 더 강력한 인터페이스 또는 객체를 만들어야 하는 상황에 유용하다. 이러한 패턴의 가장 큰 장점은
향상된 기능을 깔끔하게 구현할 수 있다는 것이다. 즉 여러 개의 객체를 조합하거나 작고 응집력 높은 인터페이스들을 조합하기만 하면 된다.

### (1) 어댑터 패턴

wrapper라고도 하는 이 패턴은 호환되지 않은 두 개 이상의 객체에 대한 인터페이스를 동시에 사용할 수 있게 한다. 개발을 하다보면 일반적으로 다형성을 가진
여러 클래스나 모델을 사용하게 된다. 하지만 기존 인터페이스와 호환이 되지 않을 뿐만 아니라 수정 권한이 없는 경우도 있을 것이다. 따라서 이러한 새로운 객체를
직접 사용하는 대신에 해당 객체를 수용할 수 있는 새로운 인터페이스를 개발할 필요가 있다. 

예를 들어 fetch 메서드를 가지는 여러 객체가 있다고 가정해보자. 새로운 추가된 객체에 fetch 메서드는 없지만 다른 이름의 메서드가 있는 경우는 사용하려는
클래스를 상속받는 클래스를 만들고 그 메서드를 래핑하는 새로운 별칭의 fetch 메서드를 추가하는 것이다.

```python
from _adapter_base import UsernameLookup

class UserSource(UsernameLookup):
    def fetch(self, user_id, username):
        user_namespace = self._adapter_arguments(user_id, username)
        return self.search(user_namespace)
    
    @staticmethod
    def _adapter_arguments(user_id, username):
        return f"{user_id}:{username}"
```

상속은 얼마나 많은 외부 라이브러리를 가져올지 정확히 알기 어렵고 강한 결합을 만들고 융통성을 떨어뜨린다. 따라서 **is a** 관계가 아니면 사용하지 않는 것이
좋다. 따라서 컴포지션을 사용하는 것이 더 좋다.

### (2) 컴포지트

프로그램에서 사용하는 객체는 내부적으로 또 다른 여러 객체를 사용해서 작업하게 된다. 잘 정의된 로직을 가진 기본 객체도 있고, 이러한 기본 객체들을 묶어서 
사용하는 컨테이너 객체도 있다. 개체는 구조화된 트리 형태이다. 기본 객체는 리프 노드이고 컨테이너 객체는 중간 노드라 볼 수 있다. 클라이언트는 이 중에 아무거나
호출하여 결과를 얻고자 할 것이다. 컴포지트 객체도 클라이언트처럼 동작한다. 리프 노드인지 중간 노드인지에 상관없이 해당 요청을 관련 노드가 처리할 수 있을 때까지
계속 전달한다.

```python
from typing import Union, Iterable


class Product:
    def __init__(self, name, price):
        self._name = name
        self._price = price
    
    @property
    def price(self):
        return self._price


class ProductBundle:
    def __init__(self, name, perc_discount, 
                 *products: Iterable[Union[Product, "ProductBundle"]]):
        self._name = name
        self._perc_discount = perc_discount
        self._products = products
    
    @property
    def price(self):
        total = sum(p.price for p in self._products)
        return total * (1 - self._perc_discount)
```

### (3) 데코레이터

데코레이터 패턴을 사용하면 상속을 하지 않고도 객체의 기능을 동적으로 확장할 수 있다.

```python
class DictQuery:
    def __init__(self, **kwargs):
        self._raw_query = kwargs

    def render(self) -> dict:
        return self._raw_query


class QueryEnhancer:
    def __init__(self, query: DictQuery):
        self.decorated = query

    def render(self):
        return self.decorated.render()


class RemoveEmpty(QueryEnhancer):
    def render(self):
        original = super().render()
        return {k: v for k, v in original.items() if v}


class CaseInsensitive(QueryEnhancer):
    def render(self):
        original = super().render()
        return {k: v.lower() for k, v in original.items()}


original = DictQuery(key="value", empty="", none=None, upper="UPPERCASE", title="Title")

print(original.render())

new_query = CaseInsensitive(RemoveEmpty(original))

print(new_query.render())
```

### (4) 파사드

파사드 패턴은 객체 간 상호 작용을 단순화하려는 많은 상황에서 유용하다. 여러 객체가 다대다 관계를 이루며 상호작용하는 경우에 사용된다. 각각의 객체에 대한
모든 연결을 만드는 대신 파사드 역할을 하는 중간 객체를 만드는 것이다. 

파사드는 허브 또는 단일 참조점의 역할을 한다. 새로운 객체가 다른 객체에 연결하려고 할 때마다 연결해야 하는 N개의 객체에 대해 N개의 인터페이스를 만들면
복잡하기 때문에 파사드와 대화하게 하고 파사드에서 적절히 요청을 전달해주면 편리할 것이다. 외부 오브젝트의 입장에서는 파사드 내부의 모든 내용이 완전히
불투명해야 한다.

---

## 3) 행동 패턴

행동 패턴은 객체가 어떻게 협력해야하는지, 어떻게 통신해야하는지, 런타임 중에 인터페이스는 어떤 형태여야 하는지에 대한 문제를 해결하는 것을 목표로 한다.

### (1) 책임 연쇄 패턴

이벤트 시스템은 텍스트 파일이나 HTTP 애플리케이션 서버에서 발생한 로그와 시스템 이벤트 정보를 파싱한다. 그리고 클라이언트에서 사용하기 편리한 형태로
데이터를 추출해줄 것이다. 책임 연쇄 패턴을 적용하면 각 이벤트에 특정 로그 라인을 처리할 수 있는지 여부를 결정하는 로직이 있고 후계자라는 개념이 추가된다.
이 후계자는 현재 이벤트가 데이터를 처리하려고 시도하고 직접 처리가 가능한 경우 결과를 반환한다. 처리가 불가능하면 후계자에게 전달하고 이러한 과정을 반복한다.

```python
import re


class Event:
    pattern = None

    def __init__(self, next_event=None):
        self.successor = next_event

    def process(self, log_line: str):
        if self.can_process(log_line):
            return self._process(log_line)

        if self.successor is None:
            return self.successor.process(log_line)

    def _process(self, log_line: str) -> dict:
        parsed_data = self._parsed_data(log_line)

        return {
            "type": self.__class__.__name__,
            "id": parsed_data["id"],
            "value": parsed_data["value"]
        }

    @classmethod
    def can_process(cls, log_line: str) -> bool:
        return cls.pattern.match(log_line) is None

    @classmethod
    def _parsed_data(cls, log_line: str) -> dict:
        return cls.pattern.match(log_line).groupdict()


class LoginEvent(Event):
    pattern = re.compile(r"(?P<id>\d+):\s+login\s+(?P<value>\S+)")


class LogoutEvent(Event):
    pattern = re.compile(r"(?P<id>\d+):\s+logout\s+(?P<value>\S+)")


chain = LogoutEvent(LoginEvent())
chain.process("567: login User")
```

책임 연쇄 패턴은 충분히 유연하고 모든 조건들이 상호 배타적이라는 특성이 있다. 판별 로직의 충돌이 없고 동일한 데이터를 하나 이상의 핸들러가 처리하지 않는다면
어떤 순서로 이벤트를 처리하는지는 상관이 없다. 뿐만 아니라 런타임에 책임을 새롭게 연결하면 변경된 우선순위를 적용할 수 있다.

### 2) 템플릿 메서드 패턴

템플릿 메서드 패턴을 사용하면 코드의 재사용성을 높여주고 객체를 보다 유연하게 하여 다형성을 유지하면서도 코드를 쉽게 수정할 수 있다. 

```python

from abc import ABCMeta, abstractmethod


class TemplateMethod:

    __metaclass__ = ABCMeta

    def execute_all_function(self):
        self.function1()
        self.function2()

    @abstractmethod
    def function1(self):
        print('execute function1')

    @abstractmethod
    def function2(self):
        print('execute function2')


class ImplementTemplate1(TemplateMethod):
    def function1(self):
        print('ImplementTemplate1 function1')

    def function2(self):
        print('ImplementTemplate1 function2')


class ImplementTemplate2(TemplateMethod):
    def function1(self):
        print('ImplementTemplate2 function1')

    def function2(self):
        print('ImplementTemplate2 function2')


it1 = ImplementTemplate1()
it2 = ImplementTemplate2()

it1.execute_all_function()
it2.execute_all_function()
```

특정 형태의 클래스 계층구조를 만들고 계층구조를 이루는 모든 클래스들은 공통된 템플릿을 공유하며 템플릿의 특정요소만 변경할 수도 있다. 또 공통 로직은
부모 클래스의 public 메서드로 구현하고 그 안에서 내부의 다른 private 메서드들을 호출하는 것이다. 이렇게 템플릿에서 호출하는 다른 내부의 메서드들은
파생 클래스에서 수정될 수 있지만 템플릿에 있는 기본 공통 로직은 모두 재사용된다.

### 3) 커맨드 

커맨드 패턴은 수행해야 할 작업을 요청한 순간부터 실제 실행 시까지 분리할 수 있는 기능을 제공한다. 또한 클라이언트가 발행한 원래 요청을 수신자와 분리할 수도
있다. 파이썬에서는 __ call __ 매직 메서드를 구현하여 호출 가능한 객체를 생성할 수 있다. 따라서 일단 객체를 초기화하고 나중에 호출을 할 수 있다.
뿐만 아니라 커맨드는 정의 이후에 수정할 수 있다. 클라이언트가 실행할 명령을 지정한 다음 누군가가 최종적으로 수행하기로 결심할 때까지는 일부 파라미터를
변경하거나 옵션을 추가할 수 있다.

### 4) 상태 패턴

상태 패턴은 구체화를 도와주는 대표적인 소프트웨어 디자인 패턴이다. 이 패턴을 사용하면 도메인 문제의 개념을 부수적인 가치에서 명시적인 객체로 전환시킬 수 있다.

```python
import abc


class InvalidTransitionError(Exception):
    """도달 불가능한 상태에서 전이할 때 발생하는 예외"""


class MergeRequestState(abc.ABC):
    def __init__(self, merge_request):
        self._merge_request = merge_request

    @abc.abstractmethod
    def open(self):
        pass

    @abc.abstractmethod
    def close(self):
        pass

    @abc.abstractmethod
    def merge(self):
        pass

    def __str__(self):
        return self.__class__.__name__


class Open(MergeRequestState):
    def open(self):
        self._merge_request.approvals = 0

    def close(self):
        self._merge_request.approvals = 0
        self._merge_request.state = Closed

    def merge(self):
        print("{} 머지".format(self._merge_request))
        print("{} 브랜치 삭제".format(self._merge_request.source_branch))
        self._merge_request.state = Merged


class Closed(MergeRequestState):
    def open(self):
        print("종료된 머지 리퀘스트 {} 재오픈".format(self._merge_request))
        self._merge_request.state = Open

    def close(self):
        pass

    def merge(self):
        raise InvalidTransitionError("종료된 요청을 머지할 수 없음")


class Merged(MergeRequestState):
    def open(self):
        raise InvalidTransitionError("이미 머지 완료됨")

    def close(self):
        raise InvalidTransitionError("이미 머지 완료됨")

    def merge(self):
        pass


class MergeRequest:
    def __init__(self, source_branch: str, target_branch: str) -> None:
        self._source_branch = source_branch
        self._target_branch = target_branch
        self._state = None
        self.approvals = 0
        self.state = Open

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, new_state_cls):
        self._state = new_state_cls(self)

    def open(self):
        return self.state.open()

    def close(self):
        return self.state.close()

    def merge(self):
        return self.state.merge()

    def __str__(self):
        return f"{self._target_branch}:{self._source_branch}"


mr = MergeRequest("develop", "master")
mr.open()

print(mr.approvals)

mr.approvals = 3

mr.close()

print(mr.approvals)

mr.open()

mr.merge()

mr.close()
```

위와 같이 상태 전이는 state 객체에 위임되고 state는 항상 MergeRequest를 가리키게 된다. state들은 모두 동일한 메시지에 대해서 적절한 처리를 한
다음 MergeRequest를 다음 상태로 전이시킨다. 

---

## 5) NULL 객체 패턴

함수나 메서드는 일관된 타입을 반환해야 한다는 것이다. 이것이 보장된다면 클라이언트는 다형성을 가진 메서드에서 반환되는 객체에 대해 null 체크를 하지 않고도
바로 사용할 수 있다. 

파이썬의 동적인 특성에 의해 대부분의 디자인 패턴은 쉽게 만들어지거나 사라진다. 원래 디자인 패턴의 주요 목표는 메서드나 함수가 작동하는데 필요한 구체적인
클래스를 명시하지 않는 것이다. 이러한 이유로 인터페이스를 새로 만들고, 기존의 객체들을 재배치하여 이러한 인터페이스에 적합하게 만드는 작업을 하는 것이다.
하지만 파이썬의 경우에는 이러한 작업이 필요하지 않고 필요한 메서드를 갖추기만 한다면 다른 객체를 그냥 전달해도 잘 동작한다. 이러한 인터페이스를 준수할
필요가 없다는 특성 때문에 메서드의 반환값에 대해서도 주의해야 한다.

따라서 None 객체를 반환하기보다는 예외를 발생시키거나 기본값을 반환하는 것이 좋다.
