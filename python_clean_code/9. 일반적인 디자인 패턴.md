# 9. 일반적인 디자인 패턴

디자인 패턴은 개발 중에 자주 발생하는 일반적인 문제들을 어떻게 추상화하여 해결할 수 있는지 다루고 이것들을 적절히 사용하여 문제들을 
쉽게 해결할 수 있도록 한다.

---

## 1. 파이썬에 디자인 패턴 적용 시 고려사항

객체 지향 디자인 패턴은 다양한 시나리오에서 해결책의 하나로 제시되는 모델 중 하나이다. 하지만 파이썬은 이미 일부 디자인 패턴을 내부적으로 구현하고 있기
때문에 실제로 필요하지 않은 패턴들이 있다. 파이썬에서 클린 코드를 달성하기 위한 중요한 목표는 어떤 패턴들이 있고 어떻게 구현할 수 있는지를 파악하는 것이다.
이미 파이썬에서 추상화한 패턴 중 일부를 인지하고 이를 활용할 수 있는 방법을 터득하는 것이다. 모든 패턴이 똑같이 자주 사용되는 것도 아니고 유용한 것도 아니다.
따라서 언어의 특성에 초점을 맞추어 실용적인 방법을 터득해야 하낟.

---

## 2. 실전 속의 디자인 패턴

디자인 패턴은 생성, 구조, 행동 패턴 중의 하나로 분류되고 이것들의 확장 버전이나 변형 버전의 패턴도 존재한다. 하지만 모든 것들을 자세히 살펴볼 필요는 없다.

첫째, 일부 패턴은 파이썬 내부에서 자체적으로 구현되어 있으므로 보이지 않은 채로도 적절히 적용될 수 있다.

둘째, 모든 패턴이 똑같이 일반적인 것은 아니다.

따라서 강제로 디자인 패턴을 적용할 필요는 없고 패턴이 출현할 때까지는 솔루션을 진화시키고 리팩토링하고 개선해야만 한다. 따라서 디자인 패턴은 발명되는 것이
아니라 발견되는 것이다. 코드에 반복적으로 같은 내용이 출현할 때 일반적이고 추상화된 클래스, 객체 또는 컴포넌트의 패턴이 발견되는 것이다.

---

## 1) 생성 패턴

소프트웨어 공학에서 생성 패턴은 객체를 인스턴스화 할 떄의 복잡성을 최대한 추상화하기 위한 것이다. 객체 초기화를 위한 파라미터를 결정하거나 초기화에 필요한
관련 객체를 준비하는 것 등의 모든 관련 작업을 단순화하려는 것이다. 이를 통해 더 간단한 인터페이스를 제공할 수 있고 사용자는 보다 안전하게 객체를
생성할 수 있다.

### (1) 팩토리

파이썬의 핵심 기능 중 하나는 모든 것이 객체라는 것이며 모두 똑같이 취급될 수 있다는 것이다. 즉, 클래스, 함수 또는 사용자 정의 객체 각각의 역할이 특별히
구분되어 있지 않다. 이들은 모두 파라미터나 할당 등에 사용될 수 있다. 이러한 이유로 파이썬에서는 팩토리 패턴이 별로 필요하지 않다.

### (2) 싱글턴과 공유 상태

일반적으로 싱글턴 패턴은 많은 문제가 있기 때문에 필요하지 않거나 나쁜 선택이다. 객체 지향 소프트웨어를 위한 전역 변수의 한 형태이고 단위 테스트가 어렵다. 
어떤 객체에 의해서 언제든지 수정될 수 있기 때문에 부작용이 크다.

파이썬에서 싱글턴을 사용하기 위한 방법은 모듈을 사용하는 것이다. 모둘에 객체를 생성하고, 모듈을 임포트한 모든 곳에서 사용할 수 있다. 파이썬에서 모듈은 이미
싱글턴이라는 것을 의미한다. 즉, 여러 번 임포트하더라도 sys.modules에 로딩되는 것은 항상 한 개다.

**공유상태**

객체가 어떻게 호출, 생성 또는 초기화 되는지에 상관없이 하나의 인스턴스만 갖는 싱글턴을 사용하는 것보다는 여러 인스턴스에서 사용할 수 있도록 데이터를 
복제하는 것이 좋다. *모노 스테이트*의 주요 개념은 싱글턴인지 아닌지에 상관없이 일반 객체처럼 많은 인스턴스를 만들 수 있어야 한다는 것이다.

Git 저장소에서 최신 태그의 코드를 가져오는 객체가 있다고 가정해보자. 이 객체의 인스턴스는 여러 개 있을 수 있고 어떤 클라이언트에서든 코드 가져오기 요청을
하면 tag라는 공통의 속성을 참조할 것이다. tag는 언제든지 새 버전으로 업데이트될 수 있고 fetch 요청을 하면 기존의 인스턴스뿐 아니라 새로운 인스턴스에서도
해당 버전을 참조해야 한다.

```python
class SharedAttribute:
    def __init__(self, initial_value=None):
        self.value = initial_value
        self._name = None
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        if self.value is None:
            raise AttributeError(f"{self._name} was never set")
        return self.value
    
    def __set__(self, instance, value):
        self.value = value
    
    def __set_name__(self, owner, name):
        self._name = name


class GitFetcher:
    current_tag = SharedAttribute()
    current_branch = SharedAttribute()
    
    def __init__(self, tag, branch=None):
        self.current_tag = tag
        self.current_branch = branch
    
    def pull(self):
        print("%s에서 풀", self.current_tag)
        return self.current_tag
```

위와 같이 디스크립터를 사용하여 문제를 해결하면 좀 더 많은 코드가 필요하지만 구체적인 책임을 캡슐화하고 코드를 분리하여 각각이 응집력을 갖게 되므로
단일 책임 원칙을 준수할 수 있게 된다.

**borg 패턴**

꼭 싱글턴을 사용해야 하는 경우라면 모노 스테이트 패턴으로 동작하는 borg 패턴을 사용하는 것이 더 좋다. 주요 개념은 같은 클래스의 모든 인스턴스가 모든 속성을
복제하는 객체를 만드는 것이다. 

**빌더**

빌더 패턴은 객체의 복잡한 초기화를 추상화하는 패턴이다. 이 패턴의 큰 개념은 필요로 하는 모든 객체를 직접 생성해주는 하나의 복잡한 객체를 만들어야 한다는
것이다. 사용자가 필요로 하는 모든 보조 객체를 직접 생성하여 메인 객체에 전달하는 것이 아니라, 한 번에 모든 것을 처리해주는 추상화를 해야 한다는 것이다.
빌더 객체는 필요한 모든 것들을 어떻게 생성하고 연결하는지를 알고 있다. 빌더 객체는 클래스 메서드와 같은 사용자 인터페이스를 제공하며, 사용자는 최종 객체에
대한 모든 정보를 해당 인터페이스에 파라미터로 전달하면 된다.


