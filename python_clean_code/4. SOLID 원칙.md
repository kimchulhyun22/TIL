# 4. SOLID 원칙

S : 단일 책임 원칙

O : 개방/폐쇄의 원칙

L : 리스코프 치환 원칙

I : 인터페이스 분리 원칙

D : 의존성 역전 원칙

---

## 단일 책임 원칙

단일 책임 원칙은 소프트웨어 컴포넌트가 단 하나의 책임을 져야 한다는 원칙이다. 클래스가 유일한 책임이 있다는 것은 하나의 구체적인 일을 담당한다는
것을 의미하며, 따라서 변화해야 할 이유는 단 하나뿐이다. 이 원칙은 보다 응집력 있는 추상화를 하는데 도움이 된다. 필요한 일 이상의 것을 하거나 너무
많은 것을 알고 있는 객체를 일컬어 신 객체라 부르는데 이러한 객체는 서로 다른 행동을 그룹화한 것이므로 유지보수가 어려워진다.

소프트웨어 디자인에서 SRP는 응집력과 밀접한 관련이 있다. 여기서 추구하려는 것은 클래스에 있는 프로퍼티와 속성이 항상 메서드를 통해서 사용되도록
하는 것이다. 이렇게 하면 이들은 관련된 개념이기 때문에 동일한 추상화로 묶는 것이 가능하다.

### 너무 많은 책임을 가진 클래스

```python
class SystemMonitor:
    def load_activity(self):
        """
            소스에서 처리할 이벤트를 가져오기
        """
        pass
    
    def identify_events(self):
        """
            가져온 데이터를 파싱하여 도메인 객체 이벤트로 전환
        """
        pass

    def strean_events(self):
        """
            파싱한 이벤트를 외부 에이전트로 전송
        """
        pass
```

위의 SystemMonitor 클래스의 메서드들은 서로 독립적으로 실행될 수 있다. 이 디자인 결함은 유지보수를 어렵게 하여 클래스가 경직되고 융통성 없으며
오류가 발생하기 쉽게 만든다. 각 메서드들은 클래스가 가진 책임을 대표한다. 즉 메서드마다 다양한 변경의 필요성이 생긴다. 

### 책임 분산

위의 코드를 보다 관리하기 쉽게 하기 위해 모든 메서드를 다른 클래스로 분리하여 각 클래스마다 단일 책임을 갖게 하자. 

````python
class ActivityReader:
    def load_activity(self):
        pass

    
class SystemMonitor:
    def identify_event(self):
        pass
    
    
class Output:
    def stream(self):
        pass

````

이렇게 클래스를 분리하면 하나의 클래스를 수정한다고 해도 다른 클래스들은 수정하지 않아도 된다. 변경 사항이 로컬에만 적용되고 영향이 미미하므로
각 클래스의 유지보수가 쉽다. 하지만 각 클래스가 딱 하나의 메서드를 가져야 한다는 것을 뜻하는 것은 아님에 주의하자. 처리해야 할 로직이 같은 경우
하나의 클래스에 여러 메서드를 추가할 수 있다.

---

## 2. 개방 폐쇄 원칙

클래스를 디자인할 때는 유지보수가 쉽도록 로직을 캡슐화하여 확장에는 개방되고 수정에는 폐쇄되도록 해야 한다. 간단히 말해서 확장 가능하고 새로운 요구사항이나
도메인 변화에 잘 적응하는 코드를 작성해야 한다는 뜻이다. 즉 새로운 문제가 발생할 경우 새로운 것을 추가만 할 뿐 기존코드는 그대로 유지해야 한다는 뜻이다.

### 개방/폐쇄 원칙을 따르지 않을 경우 유지보수의 어려움

```python
class Event:
    def __init__(self, raw_data):
        self.raw_data = raw_data
        

class UnknowEvent(Event):
    pass


class LoginEvent(Event):
    pass


class LogoutEvent(Event):
    pass


class SystemMonitor:
    def __init__(self, event_data):
        self.event_data = event_data
        
    def identify_event(self):
        if self.event_data["before"]["session"] == 0 and self.event_data["after"]["session"] == 1:
            return LoginEvent(self.event_data)
        elif self.event_data["before"]["session"] == 1 and self.event_data["after"]["session"] == 0:
            return LogoutEvent(self.event_data)
        
        return UnknowEvent(self.event_data)

```

클래스를 위와 같이 디자인한 경우에는 문제가 있다. 이벤트 유형을 결정하는 논리가 일체형으로 중앙 집중화되어 지원하는 이벤트가 늘어날수록 메서드가 커진다.
또 새로운 유형의 이벤트를 추가할 때마다 메서드를 수정해야 한다. 따라서 유지보수가 굉장히 어려워진다.

### 확장성을 가진 이벤트 시스템으로 리팩토링

우선 개방/폐쇄 원칙을 따르는 디자인을 달성하려면 추상화를 해야 한다. 위의 SystemMonitor 클래스는 추상적인 이벤트와 협력하도록 변경하고 이벤트에 대응하는
개별 로직은 각 이벤트 클래스에 위임하는 것이다. 그런 다음 각각의 이벤트에 다형성을 가진 새로운 메서드를 추가해야 한다. 

```python

class Event:
    def __init__(self, raw_data): 
        self.raw_data = raw_data
    
    @staticmethod
    def meets_condition(event_data: dict):
        return False


class UnknowEvent(Event):
    pass


class LoginEvent(Event):
    @staticmethod
    def meets_condition(event_data: dict):
        return event_data["before"]["session"] == 0 and event_data["after"]["session"] == 1


class LogoutEvent(Event):
     @staticmethod
    def meets_condition(event_data: dict):
        return event_data["before"]["session"] == 1 and event_data["after"]["session"] == 0


class SystemMonitor:
    def __init__(self, event_data):
        self.event_data = event_data

    def identify_event(self):
        for event_cls in Event.__subclasses__():
            try:
                if event_cls.meets_condition(self.event_data):
                    return event_cls(self.event_data)
            except KeyError:
                continue
        
        return UnknowEvent(self.event_data)
```

위와 같이 클래스를 구성하면 이벤트를 추가하려는 경우 Event 클래스를 상속 받아 비즈니스 로직에 따라 구현하기만 하면 확장할 수 있고 기존 코드를 수정하지
않아도 되기 때문에 개방/폐쇄 원칙을 따르는 경우라고 할 수 있다.


