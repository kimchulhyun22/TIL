# 4. SOLID 원칙

S : 단일 책임 원칙

O : 개방/폐쇄의 원칙

L : 리스코프 치환 원칙

I : 인터페이스 분리 원칙

D : 의존성 역전 원칙

---

## 단일 책임 원칙

단일 책임 원칙은 소프트웨어 컴포넌트가 단 하나의 책임을 져야 한다는 원칙이다. 클래스가 유일한 책임이 있다는 것은 하나의 구체적인 일을 담당한다는
것을 의미하며, 따라서 변화해야 할 이유는 단 하나뿐이다. 이 원칙은 보다 응집력 있는 추상화를 하는데 도움이 된다. 필요한 일 이상의 것을 하거나 너무
많은 것을 알고 있는 객체를 일컬어 신 객체라 부르는데 이러한 객체는 서로 다른 행동을 그룹화한 것이므로 유지보수가 어려워진다.

소프트웨어 디자인에서 SRP는 응집력과 밀접한 관련이 있다. 여기서 추구하려는 것은 클래스에 있는 프로퍼티와 속성이 항상 메서드를 통해서 사용되도록
하는 것이다. 이렇게 하면 이들은 관련된 개념이기 때문에 동일한 추상화로 묶는 것이 가능하다.

### 너무 많은 책임을 가진 클래스

```python
class SystemMonitor:
    def load_activity(self):
        """
            소스에서 처리할 이벤트를 가져오기
        """
        pass
    
    def identify_events(self):
        """
            가져온 데이터를 파싱하여 도메인 객체 이벤트로 전환
        """
        pass

    def strean_events(self):
        """
            파싱한 이벤트를 외부 에이전트로 전송
        """
        pass
```

위의 SystemMonitor 클래스의 메서드들은 서로 독립적으로 실행될 수 있다. 이 디자인 결함은 유지보수를 어렵게 하여 클래스가 경직되고 융통성 없으며
오류가 발생하기 쉽게 만든다. 각 메서드들은 클래스가 가진 책임을 대표한다. 즉 메서드마다 다양한 변경의 필요성이 생긴다. 

### 책임 분산

위의 코드를 보다 관리하기 쉽게 하기 위해 모든 메서드를 다른 클래스로 분리하여 각 클래스마다 단일 책임을 갖게 하자. 

````python
class ActivityReader:
    def load_activity(self):
        pass

    
class SystemMonitor:
    def identify_event(self):
        pass
    
    
class Output:
    def stream(self):
        pass

````

이렇게 클래스를 분리하면 하나의 클래스를 수정한다고 해도 다른 클래스들은 수정하지 않아도 된다. 변경 사항이 로컬에만 적용되고 영향이 미미하므로
각 클래스의 유지보수가 쉽다. 하지만 각 클래스가 딱 하나의 메서드를 가져야 한다는 것을 뜻하는 것은 아님에 주의하자. 처리해야 할 로직이 같은 경우
하나의 클래스에 여러 메서드를 추가할 수 있다.

---

## 2. 개방 폐쇄 원칙

클래스를 디자인할 때는 유지보수가 쉽도록 로직을 캡슐화하여 확장에는 개방되고 수정에는 폐쇄되도록 해야 한다. 간단히 말해서 확장 가능하고 새로운 요구사항이나
도메인 변화에 잘 적응하는 코드를 작성해야 한다는 뜻이다. 즉 새로운 문제가 발생할 경우 새로운 것을 추가만 할 뿐 기존코드는 그대로 유지해야 한다는 뜻이다.

### 개방/폐쇄 원칙을 따르지 않을 경우 유지보수의 어려움

```python
class Event:
    def __init__(self, raw_data):
        self.raw_data = raw_data
        

class UnknowEvent(Event):
    pass


class LoginEvent(Event):
    pass


class LogoutEvent(Event):
    pass


class SystemMonitor:
    def __init__(self, event_data):
        self.event_data = event_data
        
    def identify_event(self):
        if self.event_data["before"]["session"] == 0 and self.event_data["after"]["session"] == 1:
            return LoginEvent(self.event_data)
        elif self.event_data["before"]["session"] == 1 and self.event_data["after"]["session"] == 0:
            return LogoutEvent(self.event_data)
        
        return UnknowEvent(self.event_data)

```

클래스를 위와 같이 디자인한 경우에는 문제가 있다. 이벤트 유형을 결정하는 논리가 일체형으로 중앙 집중화되어 지원하는 이벤트가 늘어날수록 메서드가 커진다.
또 새로운 유형의 이벤트를 추가할 때마다 메서드를 수정해야 한다. 따라서 유지보수가 굉장히 어려워진다.

### 확장성을 가진 이벤트 시스템으로 리팩토링

우선 개방/폐쇄 원칙을 따르는 디자인을 달성하려면 추상화를 해야 한다. 위의 SystemMonitor 클래스는 추상적인 이벤트와 협력하도록 변경하고 이벤트에 대응하는
개별 로직은 각 이벤트 클래스에 위임하는 것이다. 그런 다음 각각의 이벤트에 다형성을 가진 새로운 메서드를 추가해야 한다. 

```python

class Event:
    def __init__(self, raw_data): 
        self.raw_data = raw_data
    
    @staticmethod
    def meets_condition(event_data: dict):
        return False


class UnknowEvent(Event):
    pass


class LoginEvent(Event):
    @staticmethod
    def meets_condition(event_data: dict):
        return event_data["before"]["session"] == 0 and event_data["after"]["session"] == 1


class LogoutEvent(Event):
     @staticmethod
    def meets_condition(event_data: dict):
        return event_data["before"]["session"] == 1 and event_data["after"]["session"] == 0


class SystemMonitor:
    def __init__(self, event_data):
        self.event_data = event_data

    def identify_event(self):
        for event_cls in Event.__subclasses__():
            try:
                if event_cls.meets_condition(self.event_data):
                    return event_cls(self.event_data)
            except KeyError:
                continue
        
        return UnknowEvent(self.event_data)
```

위와 같이 클래스를 구성하면 이벤트를 추가하려는 경우 Event 클래스를 상속 받아 비즈니스 로직에 따라 구현하기만 하면 확장할 수 있고 기존 코드를 수정하지
않아도 되기 때문에 개방/폐쇄 원칙을 따르는 경우라고 할 수 있다.


---

## 3. 리스코프 치환 원칙

리스코프 치환 원칙은 설계 시 안정성을 유지하기 위해 객체 타입이 유지해야하는 일련의 특성을 말한다. LSP는 어떤 클래스에서든 클라이언트는 특별한
주의를 기울이지 않고도 하위 타입을 사용할 수 있어야 한다는 것이다. 어떤 하위 타입을 사용해도 실행에 따른 결과를 염려하지 않아야 한다. 즉, 클라이언트는
완전히 분리되어 있으면 클래스 변경 사항과 독립되어야 한다. 즉, 계층 구조가 올바르게 구현되었다면 클라이언트 클래스가 주의를 기울이지 않고도 모든
하위 클래스의 인스턴스로 작업할 수 있어야 한다는 것이다. 하위 클래스가 상위 클래스에서 상속받은 메서드의 반환형이나 파라미터를 변경하면 안된다.

### 애매한 LSP 위반 사례

1. 하위 클래스는 부모 클래스에 정의된 것보다 사전조건을 엄격하게 만들면 안된다.
2. 하위 클래스는 부모 클래스에 정의된 것보다 약한 사후조건을 만들면 안된다. 

만약 하위 클래스에서 사전조건을 더 엄격하게 정의한 경우에는 클라이언트 클래스에서 예상치 못한 예외나 오류 상황으로 빠질 수 있고 사후 조건에 대해서는
예상치 못한 결과를 얻을 수 있기 때문에 계약에 의한 디자인을 위반할 수 있다.

---

## 4. 인터페이스 분리 원칙

인터페이스 분리 원칙은 작은 인터페이스에 대한 가이드라인을 제공한다. 다중 메서드를 가진 인터페이스가 있다면 매우 정확하고 구체적인 구분에 따라
더 적은 수의 메서드를 가진 여러 개의 메서드로 분할하는 것이 좋다. 재사용성을 높이기 위해 가능한 작은 단위로 인터페이스를 분리한다면 인터페이스 중
하나를 구현하려는 각 클래스가 매우 명확한 동작과 책임을 지니기 때문에 응집력이 높아진다.

### 인터페이스는 작을수록 좋다

인터페이스를 같은 개념끼리 구성하게 되면 새로운 기능들을 유연하게 조합할 수 있다. 단일 책임 원칙과 비슷하지만 인터페이스 분리 원칙은 인터페이스에 대해
정의한다. 인터페이스는 구현체가 만들어지기 전까지는 변경할 이유가 없지만 이 원칙을 준수하지 않으면 별개의 기능이 결합된 인터페이스를 만들게 된다.
이러한 인터페이스를 상속받으면 단일 책임 원칙 또한 지킬 수 없게 된다.

### 인터페이스는 얼마나 작아야 할까?

인터페이스는 가능한 작으면 좋지만 그렇다고 반드시 하나의 메서드만 존재해야 하는 것은 아니다. 응집력의 관점에서 가능한 한 가지 일을 수행하는
인터페이스여야 한다. 

---

## 5. 의존성 역전

의존성 역전 원칙은 코드가 깨지거나 손상되는 취약점으로부터 보호해주는 흥미로운 디자인 원칙을 제시한다. 의존성을 역전시킨다는 것은 코드가 세부사항이나
구체적인 구현에 적응하도록 하지 않고, 대신에 API 같은 것에 적응하도록 하는 것이다. 추상화를 통해 세부 사항에 의존하지 않고 반대로 세부 사항은
추상화에 의존해야 한다. 

A와 B 두 객체가 상호 교류를 한다고 생각해보자. A는 B의 인스턴스를 사용하지만 우리가 B 모듈을 관리하지 않는다. 만약 B에 의존하면 B 코드가
변경되면 원래의 코드는 쉽게 깨지게 된다. 따라서 이를 방지하기 위해 의존성을 거꾸로 뒤집어서 역전시켜야 한다. 즉 B가 A에 적응해야 한다. 이렇게
하려면 인터페이스를 개발하고 코드가 B의 구체적인 구현에 의존하지 않도록 해야 한다. 



