# 8. 단위 테스트와 리팩토링

---

## 디자인 원칙과 단위 테스트

단위 테스트는 다른 코드의 일부분이 유효한지를 검사하는 코드이다. 단위 테스트는 비즈니스 로직이 특정 조건을 보장하는지를 확인하기 위해 여러 시나리오를 검증하는
코드이다.

**단위 테스트의 특징**
- 격리 : 단위 테스트는 다른 외부 에이전트와 완전히 독립적이어야 하며 비즈니스 로직에만 집중해야 한다. 즉, 테스트는 이전 상태에 관계없이 임의의 순서로 실행되어야 한다.

- 성능 : 단위 테스트는 신속하게 실행되어야 한다. 반복적으로 여러번 실행될 수 있도록 설계해야 한다.

- 자체 검증 : 단위 테스트의 실행만으로 결과를 결정할 수 있어야 한다.

### 자동화된 테스트의 다른 형태

단위 테스트는 함수 또는 메서드와 같은 매우 작은 단위를 확인하기 위한 것이다. 단위 테스트는 최대한 자세하게 코드를 검사하는 것이 목적이다. 
클래스를 테스트하려면 단위 테스트가 아니라 단위 테스트의 집합인 테스트 스위트(test suite)를 사용한다. 테스트 스위트를 구성하는 테스트들은 메서드처럼 보다
작은 것을 테스트한다.

**통합 테스트**는
한 번에 여러 컴포넌트를 테스트한다. 종합적으로 예상대로 잘 동작하는지 검증한다. HTTP 요청을 하거나 데이터베이스에 연결하는 등의 작업을 수행하는 것이
바람직하다.

**인수 테스트**는 유스 케이스를 활용하여 사용자의 관점에서 시스템의 유효성을 검사하는 자동화된 테스트이다.

일반적으로 단위 테스트는 항상 수행되길 원하지만 통합 테스트나 인수 테스트는 그보다 덜 자주 수행되길 바란다. 단위 테스트에서 작은 기능을 많이 테스트하고
단위 테스트에서 확인할 수 없는 부분을 다른 자동화된 테스트에서 커버해야 하기 때문이다. 

### 단위 테스트와 애자일 소프트웨어 개발

최근에는 더 빠르게 피드백을 받을수록 더 쉽게 코드를 수정할 수 있다고 생각하기 때문에 가능한 지속적으로 신속하고 지속적으로 가치를 제공하려 한다. 따라서
소프트웨어를 유연하고 확장 가능하도록 구현하여 효과적으로 대응할 수 있도록 해야 한다. 아무리 변화에 쉽게 대응하는 소프트웨어를 작성했다고 해도 버그가 없다는
것을 증명할 순 없다. 따라서 단위테스트를 통해 코드가 기대한 것처럼 동작한다는 것을 알 수 있다. 

### 단위 테스트와 소프트웨어 디자인

좋은 소프트웨어는 테스트 가능한 소프트웨어이다. 테스트의 용이성은 있으면 좋은 것이 아니라 클린 코드의 핵심 가치이다. 단위 테스트는 기본 코드를 보완하기
위한 것이 아니라 실제 코드의 작성 방식에 영향을 미친다. 메서드가 작아야 테스트하기 용이하기 때문이다. 

### 테스트의 경계 정하기

테스트의 범위는 우리가 작성한 코드의 범위로 한정해야 한다. 그렇지 않고 외부 라이브러리나 모듈과 같은 의존성까지 확인해야 한다면 끝이 없을 것이다. 의존성을
테스트하는 것은 우리의 책임이 아니다. 외부 의존성은 올바른 파라미터를 사용해 호출하면 정상적으로 실행된다는 것만 확인해도 충분하다.

좋은 단위 테스트는 시스템의 경계에는 패치를 적용하여 넘어가고 핵심 기능에 초점을 둔다. 

---

## 2. 테스트를 위한 프레임워크와 도구

### 단위 테스트 프레임워크와 라이브러리

파이썬 테스트 프레임워크
- unittest : 다양한 헬퍼 기능을 제공하므로 테스트 시나리오를 다루기에 충분하다
- pytest : 외부 시스템에 연결하는 등의 의존성이 많은 경우 테스트 케이스를 파라미터화할 수 있는 픽스처라는 패치 객체가 필요한 경우에 적합하다

### unittest

unittest 모듈은 모든 종류의 테스트를 작성할 수 있는 풍부한 API를 제공하므로 단위 테스트를 하기에 좋다. unittest 모듈은 자바의 JUnit 기반으로 한다.
객체를 사용해 테스트를 작성하고 클래스의 시나리오별로 테스트를 그룹화하는 것이 일반적이다.

단위 테스트를 만들려면 unittest.TestCase를 상속하여 테스트 클래스를 만들고 메서드에 테스트할 조건을 정의하면 된다. 메서드는 test_로 시작해야하고
본문에서는 unittest.TestCase에서 상속받은 메서드를 사용하여 체크하려는 조건이 참인지 확인하면 된다.

예제 코드
```python
from enum import Enum


class MergeRequestStatus(Enum):
    APPROVED = "approved"
    REJECTED = "rejected"
    PENDING = "pending"
    

class MergeRequest:
    def __init__(self):
        self._context = {
            "upvotes" : set(),
            "downvotes" : set()
        }
        
    @property
    def status(self):
        """
            MergeRequest의 상태 정보
            
            - 한 명 이상의 사용자가 변경 내용에 동의하지 않은 경우 머지 리퀘스트는 거절
            - 아무도 반대하지 않은 상태에서 두 명 이상의 개발자가 동의하면 해당 머지 리퀘스트는 승인된다
            - 이 외의 상태는 보류 상태이다
        :return: 
        """
        if self._context["downvotes"]:
            return MergeRequestStatus.REJECTED
        elif len(self._context["upvotes"]) >= 2:
            return MergeRequestStatus.APPROVED
        
        return MergeRequestStatus.PENDING
    
    def upvote(self, by_user):
        self._context["downvotes"].discard(by_user)
        self._context["upvotes"].add(by_user)
    
    def downvote(self, by_user):
        self._context["upvotes"].discard(by_user)
        self._context["downvotes"].add(by_user)
```

테스트 코드
```python
class TestMergeRequestStatus(unittest.TestCase):
    def test_simple_rejected(self):
        merge_request = MergeRequest()
        merge_request.downvote("maintainer")
        self.assertEqual(merge_request.status, MergeRequestStatus.REJECTED)

    def test_just_created_is_pending(self):
        self.assertEqual(MergeRequest().status, MergeRequestStatus.PENDING)

    def test_pending_awaiting_review(self):
        merge_request = MergeRequest()
        merge_request.upvote("core-dev")
        self.assertEqual(merge_request.status, MergeRequestStatus.PENDING)

    def test_approved(self):
        merge_request = MergeRequest()
        merge_request.upvote("dev1")
        merge_request.upvote("dev2")
        self.assertEqual(merge_request.status, MergeRequestStatus.APPROVED)
```

### pytest

pytest도 unittest처럼 테스트 시나리오를 클래스로 마들고 객체 지향 모델을 생성하는 것이 가능하다. 단순히 assert 구문을 사용해 조건을 검사하는 것이
가능하기 때문에 자유롭게 코드를 작성할 수 있다. pytest에서는 assert 비교만으로 단위 테스트를 식별하고 결과를 보고하는 것이 가능하다. 뿐만 아니라
pytest 명령어를 통해 탐색 가능한 모든 테스트를 한번에 실행한다.

테스트 코드
```python
import pytest


def test_simple_rejected():
    merge_request = MergeRequest()
    merge_request.downvote("maintainer")
    assert merge_request.status == MergeRequestStatus.REJECTED


def test_just_created_is_pending():
    assert MergeRequest().status == MergeRequestStatus.PENDING


def test_pending_awaiting_review():
    merge_request = MergeRequest()
    merge_request.upvote("core-dev")
    assert merge_request.status == MergeRequestStatus.PENDING


def test_invalid_types():
    merge_request = MergeRequest()
    pytest.raises(TypeError, merge_request.upvote, {"invalid-object"})
```


