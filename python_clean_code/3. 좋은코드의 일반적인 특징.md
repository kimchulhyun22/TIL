# 3장 좋은 코드의 일반적인 특징

코드를 가능한 견고하고 결함을 최소화하기 위해 훌륭한 소프트웨어 디자인 원칙에 대해 알아본다.

---

## 1. 계약에 의한 디자인

컴포넌트는 기능을 숨겨 캡슐화하고 함수를 사용할 고객에게는 애플리케이션 프로그래밍 인터페이스를 노출해야 한다. 컴포넌트의 함수, 클래스, 메서드는
특별한 유의사항에 따라 동작해야 하며, 그렇지 않을 경우 코드가 깨지게 된다. 반대로 코드를 호출하는 클라이언트는 특정 응답을 기대하며 이것과 다른
경우 함수 호출에 실패하고 결함이 생긴다. API를 디자인할 때 예상되는 입력, 출력 및 부작용을 문서화해야 한다. 그러나 모든 소프트웨어의 동작을
문서화할 수는 없다. 따라서 코드가 정상적으로 동작하기 위해 기대하는 것과 호출자가 반환받기를 기대하는 것은 디자인의 하나가 되어야 한다. 여기서
계약이라는 개념이 생긴다.

### 계약에 의한 디자인이란?
계약에 의한 디자인이란 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 먼저 한 다음, 계약을 어겼을 경우는 명시적으로
왜 계속할 수 없는지 예외를 발생시키라는 것이다. 이 책에서 말하는 계약이란 컴포넌트 간의 통신 중에 반드시 지켜져야 할 몇가지 규칙을 강제하는 것이다.

- 사전조건 -> 함수가 진행되기 전에 체크하는 모든 조건

- 사후조건 -> 함수 반환값의 유효성 검사

- 불변식 -> 함수가 실행되는 동안에 일정하게 유지되는 것

- 부작용 -> 코드의 부작용

### 계약에 의한 디자인이 좋은 이유
사전조건과 사후조건은 코드 레벨에서 체크해야 한다. 이렇게 계약에 의해 디자인을 하는 이유는 오류가 발생할 때 쉽게 찾아낼 수 있기 때문이다. 
사전조건 또는 사후조건 검증에 실패할 경우 오류를 쉽게 찾아서 수정할 수 있다. 뿐만 아니라 잘못된 가정 하에 코드가 실행되는 것을 방지할 수 있다.
이렇게 하면 책임소재를 신속하게 파악할 수 있다. 사전조건 검증이 실패하면 클라이언트의 결함이고 사후조건 검증이 실패하면 특정 모듈이나 제공 클래스의 결함이기
때문이다.

### 사전조건

사전조건이란 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것을 말한다. 파이썬은 동적 타입 언어이기 때문에 전달된 데이터가 적절한 타입인지
확인하는 경우도 있다. 또 처리할 정보에 대해 적절한 유효성 검사를 해야 한다. 사전조건 검증은 클라이언트에서 하거나 함수 자체에 두어야 한다.
중복으로 처리해서는 안된다.

### 사후조건

사후조건이란 메서드 또는 함수가 반환된 후의 상태를 강제하는 것이다. 사후조건을 사용하여 클라이언트가 필요로 하는 모든 것을 검사하고 메서드가
적절히 실행되었다면 계약이 이루어진 것이기 때문에 사후조건 검증에 통과하고 클라이언트는 반환된 객체를 아무 문제없이 사용할 수 있어야 한다.

### 파이썬스러운 계약

파이썬스러운 계약에 있어서 가장 좋은 방법은 메서드, 함수 및 클래스에 RuntimeError 에러 또는 ValueError 예외를 발생시키는 것이다. 또는
적절한 예외를 발생시키기 어렵다면 사용자 정의 예외를 만들어야 한다. 또 사전조건에 대한 검사와 사후조건에 대한 검사 그리고 핵심 기능에 대한
구현을 분리해야 한다.

---

## 2. 방어적 프로그래밍

방어적 프로그래밍은 Dbc(Design by contract)와 다르게 예외를 발생시키고 실패하는 것보다는 객체, 함수 또는 메서드와 같은 코드의 모든 부분을
유효하지 않은 것으로부터 스스로 보호할 수 있게 하는 것이다. 

### 에러 핸들링

오류가 발생하기 쉬운 상황에서 에러 핸들링 프로시저를 사용하는데 일반적으로 데이터 입력 확인 시 자주 사용된다. 에러 핸들링의 주요 목적은 예상되는
에러에 대해서 실행을 계속할 수 있을지 아니면 극복할 수 없는 오류여서 프로그램을 중단할지를 결정하는 것이다.

#### 예외처리 방법
1. 값 대체
2. 에러 로깅
3. 예외 처리

### 1) 값 대체

일부 시나리오에서는 오류가 있어 소프트웨어가 잘못된 값을 생성하거나 전체가 종료될 위험이 있는 경우 값을 안전한 다른 값으로 대체할 수 있다. 기본 값
또는 잘 알려진 상수, 초기 값으로 바꿔 잘못된 결과를 정합성을 깨지 않는 다른 값으로 대체하는 것을 말한다. 하지만 값 대체가 항상 가능하진 않다.
견고성과 정확성 간의 트레이드오프 때문에 예상치 못한 상황에서도 실패하지 않아야 견고하다고 할 수 있지만 실패하지 않는 것이 항상 옳은 것은 아니다.
누락된 데이터를 기본 값으로 바꾸어도 큰 문제가 없지만 오류가 있는 데이터를 유사한 값으로 대체하는 것은 위험하다.

### 2) 예외 처리

잘못되거나 누락된 입력 데이터가 있는 경우 복구 처리가 가능한 경우가 있다. 하지만 어떤 경우에는 에러가 발생하기 쉽다는 가정으로 계속 실행하는 것보다
실행을 멈추는 것이 더 좋다. 호출자에게 실패했음을 알리는 것이 더 좋은 선택이다. 하지만 너무 많은 예외를 발생시키면 호출자가 발생 가능한 모든 부작용을
염두에 두어야 한다. 또 함수가 응집력이 약하고 너무 많은 책임을 가지고 있다는 것을 뜻할 수 있기 때문이다. 파이썬의 예외와 관련된 몇 가지 권장 사항을 
알아보자.

#### 올바른 수준의 추상화 단계에서 예외 처리

예외는 오직 한 가지 일을 하는 함수의 한 부분이어야 한다. 함수가 처리하는 예외는 캡슐화된 로직과 일치해야 한다. 

```python
import requests

url = 'www.google.com'


def bad_example():
    try:
        req = requests.get(url)
        process_data(req.json())
        
    except KeyError:
        print('Key Error')

    except requests.exceptions.ConnectionError:
        print('Connection Error')


def process_data(data):
    print(data['data'])
```

위와 같은 코드를 보면 KeyError와 ConnectionError 예외를 처리하는 것을 알 수 있다. 하지만 두 예외는 관계가 없다. 따라서 책임을 분산해야 할 필요성을
느껴야 한다. ConnectionError는 따로 connection을 담당하는 함수를 만들어 예외를 처리하고 KeyError는 process_data 함수 내에서 처리하면 
해당 함수는 예외를 catch할 필요가 없다. 따라서 함수 안에서 다른 수준의 예외를 처리하고 있다면 적절히 분리하도록 하자.

#### Traceback 노출 금지

예외를 처리할 때 오류가 너무 중요하면 전파해도 괜찮다. 또한 특정 시나리오에서 검토된 내용이거나 견고함보다 정확성이 중요한 상황이라면 프로그램을 종료하게
할 수도 있다. 특정 문제를 나타내는 예외가 있는 경우 문제를 효율적으로 해결할 수 있도록 traceback 정보, 메시지 및 기타 수집 가능한 정보를 로그로 남기는 것이
중요하다. 그러나 세부사항은 사용자에게 보여서는 안된다. 이것은 보안과 관련되어 있고 중요 정보가 유출될 위험이 있기 때문이다. 따라서 사용자에게 문제를
알리려면 무엇이 잘못되었다거나 페이지를 찾을 수 없다는 등의 일반적인 메시지를 사용해야 한다.


#### 비어있는 except 블록 지양

일부 오류에 대비하여 프로그램을 방어하는 것은 좋은 일이지만 너무 방어적인 것은 더 심각한 문제로 이어질 수 있다. 오류를 조용히 지나쳐버리는 비어있는 except
블록은 가장 안 좋은 케이스다. 

```python
try:
    process_data()

except:
    pass
```

위와 같은 코드는 절대 실패하지 않는다. 실패를 반드시 해야 하는 경우에도 에러가 발생하지 않기 때문에 에러를 조용히 전달해서는 안된다는 파이썬의 철학에
어긋난다. 이러한 코드는 문제를 숨기고 유지보수를 더 어렵게 만든다. 따라서 광범위한 예외보다는 구체적인 예외를 사용하고 except 블록에서 실제 오류 처리를
해야 한다.

#### 원본 예외 포함

오류 처리 과정에서 다른 오류를 발생시키고 메시지를 변경할 수도 있다. 이 경우 원래 예외를 포함하는 것이 좋다. 
파이썬에서 raise <e> from <original_exception> 구문을 사용하면 된다.


### 파이썬에서 어설션 사용하기

어설션은 절대로 일어나지 않아야 하는 상황에 사용되므로 assert문에 사용된 표현식은 불가능한 조건을 의미한다. 이 상태가 된다는 건 소프트웨어에 결함이 있음을
의미한다. 어설션은 잘못된 시나리오에 도달할 경우 프로그램이 더 큰 피해를 입지 않도록 하는 것이다. 따라서 계속 처리하기보다는 프로그램을 중단시키는 것이 더
좋다. 또 어설션 문장에 설명이 포함된 오류 메시지를 작성하여 나중에 디버깅하고 수정할 수 있도록 한다. 

---

## 3. 관심사의 분리

책임이 다르면 컴포넌트, 계층 또는 모듈로 분리되어야 한다. 프로그램의 각 부분은 기능의 일부분에 대해서만 책임을 지며 나머지 부분에 대해서는 알 필요가 없다.
소프트웨어에서 관심사를 분리하는 목표는 파급 효과를 최소화하여 유지보수성을 향상시키는 것이다. 함수를 약간만 변경해도 코드의 여러 부분에 영향을 미치는 것을
의도하는 개발자는 없다. 따라서 애플리케이션의 나머지 부분에 대한 영향성을 최소화하면서 코드를 수정하거나 리팩토링을 하고 싶다면 적절한 캡슐화가 필요하다.

### 응집력과 결합력

'응집력'이란 객체가 작고 잘 정의된 목적을 가져야 하며 가능하면 작아야 한다는 것을 의미한다. 객체의 응집력이 높을수록 더 유용하고 재사용성이 높아진다.

'결합력'이란 두 개 이상의 객체가 서로 어떻게 의존하는지를 나타낸다. 객체 또는 메서드의 두 부분이 서로 너무 의존적이라면 바람직하지 않은 결과를 가져온다.

#### 바람직하지 않은 결과
1. 낮은 재사용성
2. 파급 효과
3. 낮은 수준의 추상화

---

## 4. 개발 지침 약어

### DRY / OAOO

DRY(Do not Repeat Yourself)와 OAOO(Once And Only Once)는 중복을 반드시 피해야 한다는 말이다. 코드에 있는 지식은 단 한번, 단 한 곳에 정의되어
야 한다. 코드를 변경하려고 할 때 수정이 필요한 곳은 단 한군데만 있어야 한다. 

#### 코드 중복이 미치는 부정적인 영향
1. 오류가 발생하기 쉽다
2. 비용이 비싸다
3. 신뢰성이 떨어진다

중복은 기존 코드의 지식을 무시함으로써 발생한다. 코드의 특정 부분에 의미를 부여함으로써 해당 지식을 식별하고 표시할 수 있다.
불행하게도 파이썬의 어떤 기능이 코드 중복 문제를 해결하는데 가장 적합한지를 알려주는 일반적인 규칙이나 패턴은 없다. 따라서 파이썬의 구성요소를 통해 자신만의
직관을 발전시켜야 한다.

### YAGNI

YAGNI(You Ain't Gonna Need it)은 과잉 엔지니어링을 하지 않기 위해 솔루션 작성 시 계속 염두에 두어야 한다는 원칙이다. 우리는 프로그램을 쉽게 수정하기
원한다. 따라서 미래의 모든 요구사항을 고려하여 매우 복잡한 솔루션을 만들고, 추상화를 하여 읽기 어렵고, 유지보수가 어렵고, 이해하기 어려운 코드를 만든다.
하지만 유지보수가 가능한 소프트웨어를 만드는 것은 미래의 요구 사항을 예측하는 것이 아니다. 오직 현재의 요구사항을 잘 해결하기 위한 소프트웨어를 작성하고
가능한 나중에 수정하기 쉽도록 작성하는 것이다.

### KIS

KIS(Keep It Simple)은 소프트웨어 컴포넌트를 설계할 떄 과잉 엔지니어링을 피해야 한다. 문제를 올바르게 해결하는 최소한의 기능을 구현하고 필요한 것 이상으로
솔루션을 복잡하게 만들지 않도록 해야 한다. 기억해야 할 점은 디자인이 단순할 수록 유지 관리가 쉽다는 것이다. 일반적으로 코드 측면의 단순함이란 문제에 맞는
가장 작은 데이터 구조를 사용하는 것을 말한다. 코드를 지나치게 복잡하게 만들고 필요한 것보다 더 많은 함수 또는 메서드를 만들 필요가 없다는 것이다.

### EAFP / LBYL

EAFP(Easier to Ask Forgiveness than Permission)은 허락보다는 용서를 구하는 것이 더 쉽다는 것이고, LBYL(Look Before You Leap)은 도약하
기 전에 살피라는 뜻이다.

EAFP는 일단 코드를 실행하고 실제 동작하지 않을 경우에 대응한다는 뜻이다. 코드를 실행하고 발생한 예외를 catch하고 except 블록에서 바로잡는 코드를 실행한다.

LBYL은 도약하기 전에 무엇을 사용하려고 하는지 확인하라는 뜻이다.

하지만 파이썬에서는 LBYL보다는 EAFP 방식으로 만들어졌으며 이렇게 할 것을 권장한다.

---

## 5. 컴포지션과 상속

상속은 강력한 개념이지만 위험도 있다. 가장 큰 위험은 부모 클래스를 확장하여 새로운 클래스를 만들 때마다 부모와 강력하게 결합된 새로운 클래스가 생긴다는 점이다.
하지만 소프트웨어를 설계할 때 결합력을 최소한으로 줄이는 것이 중요하다. 상속을 통해 가장 많이 사용하는 기능은 코드 재사용이다. 하지만 단지 부모 클래스에 있는
메서드를 공짜로 얻을 수 있기 때문에 상속하는 것은 좋지 않은 생각이다. 코드를 재사용하는 올바른 방법은 여러 상황에서 동작 가능하고 쉽게 조합할 수 있는 응집력
높은 객체를 사용하는 것이다.

### 상속이 좋은 선택인 경우

파생 클래스를 만드는 것은 양날의 검이 될 수 있다. 부모의 메서드를 공짜로 전수 받을 수 있는 장점이 있지만 다른 한편으로 모든 것을 새로운 클래스로 가져왔기
때문에 새로운 정의에 너무 많은 기능을 추가하게 되는 단점도 있다. 새로운 하위 클래스를 만들 때 클래스가 올바르게 정의되었는지 확인하기 위해 상속된 모든
메서드를 실제로 사용할 것인지 생각해보는 것이 좋다. 만약 대부분의 메서드를 필요로 하지 않고 재정의하거나 대체해야 한다면 다음과 같은 이유로 설계상의 실수라고
할 수 있다.

1. 상위 클래스는 잘 정의된 인터페이스 대신 막연한 정의와 너무 많은 책임을 가졌다.
2. 하위 클래스는 확장하려고 하는 상위 클래스의 적절한 세분화가 아니다.

상속을 잘 사용한 예는 다음과 같다. public 메서드와 속성 인터페이스를 정의한 컴포넌트가 있다. 그리고 이 클래스의 기능을 그대로 물려받으면서 추가 기능을
더하려는 경우 또는 특정 기능을 수정하려는 경우이다.

인터페이스 정의는 상속의 또 다른 좋은 예이다. 어떤 객체에 인터페이스 방식을 강제하고자할 때 구현을 하지 않은 기본 추상 클래스를 만들고, 실제 이 클래스를
상속하는 하위 클래스에서 적절한 구현을 하도록 하는 것이다.

파이썬의 표준 예외는 Exception에서 파생된다. 따라서 except Exception을 통해 모든 에러를 catch할 수 있다. 모든 예외가 Exception 클래스를 상속받았
다는 것이다.

### 상속 안티패턴

상속을 올바르게 사용하면 객체를 전문화하고 기본 객체에서 출발하여 세부적인 추상화를 할 수 있다. 부모 클래스는 새 파생 클래스의 공통 정의의 일부가 된다.
상속된 메서드가 새로운 클래스의 일부가 되기 때문이다. 따라서 클래스의 public 메서드는 부모 클래스가 정의하는 것과 일치해야 한다.
하지만 코드 재사용만을 목적으로 상속을 사용한다면 불필요한 메서드까지 같이 상속받거나 개념적인 확장이라는 것을 유추할 수 없을 것이다.
따라서 상속보다는 컴포지션을 이용하여 구현하는 것도 염두에 두어야 한다. 

### 파이썬의 다중상속

다중 상속은 유익할 수 있지만 올바르게 구현되지 않으면 큰 문제를 초래할 수 있다. 다중 상속은 올바르게 사용될 때에만 유효한 해결책이 될 수 있으므로 
새로운 패턴과 믹스인을 사용하게 되었다. 다중 상속의 동작 원리를 먼저 파악하자.

#### 1) 메서드 결정 순서

기본적으로 파이썬에서 다중 상속 시 메서드는 C3 linearization 또는 MRO 알고리즘을 사용한다.  따라서 가장 먼저 자신 클래스의 메서드가 호출되고
그다음 먼저 상속받은 순서대로 클래스의 메서드로 결정되고, 그다음은 최상위 클래스의 메서드로 결정된다. 

#### 2) 믹스인

믹스인은 코드를 재사용하기 위해 일반적인 행동을 캡슐화해놓은 기본 클래스이다. 보통은 다른 클래스와 믹스인 클래스를 다중 상속하여 믹스인에 있는 메서드나 속성을
사용한다.

---

## 5. 함수와 메서드의 인자

### 파이썬의 함수 인자는 어떻게 복사되는가

파이썬은 모든 인자가 값에 의해 전달된다. 하지만 변형 가능한 객체를 전달하고 함수에서 값을 변경하면 부작용이 생길 수 있다. 변형 가능한 객체를
인자로 전달할 경우 객체의 참조를 보유하고 있어 값을 수정할 경우 전달된 객체의 값이 수정되기 때문이다. 

### 가변인자

가변 인자를 사용하려면 해당 인자를 패킹할 변수의 이름 앞에 별표를 사용하면 되는데 이것은 파이썬의 패킹 메커니즘에 따른 것이다.

```python
def func(first, second ,third):
    print(first)
    print(second)
    print(third)
    

l = [1, 2, 3]

# Bad
func(l[0], l[1], l[2])

# Good
func(*l)
```

이러한 파이썬의 패킹 메커니즘은 반대 방향으로도 동작한다.

```python
a, b, c = [1, 2, 3]
```

### 함수 인자의 개수

너무 많은 인자를 사용하는 함수나 메서드가 왜 나쁜 디자인의 징후인지를 살펴보고 이 문제를 해결할 방법을 알아보자.
첫 번째는 구체화하는 것이다. 모든 인자를 포함하는 새로운 객체를 만드는 것이다. 두 번째는 파이썬이 가진 가변 인자나 키워드 인자를 사용하는 것이다.
하지만 그 전에 파라미터의 갯수가 너무 많다면 함수에서 많은 것들을 처리하고 있지는 않은지 확인 후 여러 작은 함수로 분리하도록 하자.

#### 함수 인자와 결합력

함수의 인자가 많을 수록 호출자 함수와 밀접하게 결합될 가능성이 커진다. 이런 경우 추상화가 부족했을 가능성이 크고 강하게 결합되기 때문에 재사용성이
떨어진다. 따라서 이런 경우는 새로운 상위 레벨의 추상화 객체를 필요로 하거나 누락된 객체가 있음을 의미하므로 리팩토링하도록 한다.

#### 많은 인자를 취하는 작은 함수의 서명

너무 많은 파라미터를 사용하는 함수를 리팩토링할 때 공통 객체에 파라미터 대부분이 포함되어 있는 경우는 공통 객체 자체를 파라미터로 전달하는 것이
있다.

```python
class Request:
    def __init__(self, headers='', ip_addr='', request_id=''):
        self.headers = headers
        self.ip_addr = ip_addr
        self.request_id = request_id

def track_request(headers, ip_addr, request_id):
    pass

request = Request()

track_request(request.headers, request.ip_addr, request.request_id)

# 리팩토링 버전
def tack_request_refactoring(request: Request):
    pass

```

---

## 6. 소프트웨어 디자인 우수 사례 결론

좋은 소프트웨어 디자인이란 소프트웨어 엔지니어링의 우수 사례를 따르고 언어의 기능이 제공하는 대부분의 장점을 활용하는 디자인이다. 파이썬이 제공해야
하는 모든 것을 사용하는 데 큰 가치가 있지만, 또한 이것을 남용하고 복잡한 기능을 단순한 디자인에 껴 맞추려는 위험도 있다. 따라서 몇 가지 권장사항을
따르도록 하자.

### 소프트웨어의 독립성

모듈, 클래스 또는 함수를 변경하면 수정한 컴포넌트가 외부 세계에 영향을 미치지 않아야 한다. 항상 가능한 것은 아니지만 가능한 한 영향을 최소화하려고
시도해야 한다. 이러한 디자인 원칙으로 관심사의 분리, 응집력, 컴포넌트의 격리가 있다. 어느 함수를 변경한다고 해서 다른 함수에 영향을 미치면 안된다.
코드가 독립적이라는 것은 다른 부분에 영향을 주지 않고 변경할 수 있다는 것을 뜻한다. 이는 변경된 부분의 단위 테스트가 나머지 단위 테스트와도 독립적이라는 것을
뜻한다. 이러한 가정하에 두 개의 테스트가 통과하면 전체 회귀 테스트를 하지 않고도 애플리케이션에 문제가 없다고 확신할 수 있다.

### 코드 구조

코드를 구조화하는 방법은 팀의 작업 효율성과 유지보수성에 영향을 미친다. 특히 여러 정의가 들어있는 큰 파일을 만드는 것은 좋지 않으므로 권장하지 않는다.
유사한 컴포넌트끼리 정리하여 구조화해야 한다. 