# 3장 좋은 코드의 일반적인 특징

코드를 가능한 견고하고 결함을 최소화하기 위해 훌륭한 소프트웨어 디자인 원칙에 대해 알아본다.

---

## 1. 계약에 의한 디자인

컴포넌트는 기능을 숨겨 캡슐화하고 함수를 사용할 고객에게는 애플리케이션 프로그래밍 인터페이스를 노출해야 한다. 컴포넌트의 함수, 클래스, 메서드는
특별한 유의사항에 따라 동작해야 하며, 그렇지 않을 경우 코드가 깨지게 된다. 반대로 코드를 호출하는 클라이언트는 특정 응답을 기대하며 이것과 다른
경우 함수 호출에 실패하고 결함이 생긴다. API를 디자인할 때 예상되는 입력, 출력 및 부작용을 문서화해야 한다. 그러나 모든 소프트웨어의 동작을
문서화할 수는 없다. 따라서 코드가 정상적으로 동작하기 위해 기대하는 것과 호출자가 반환받기를 기대하는 것은 디자인의 하나가 되어야 한다. 여기서
계약이라는 개념이 생긴다.

### 계약에 의한 디자인이란?
계약에 의한 디자인이란 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 먼저 한 다음, 계약을 어겼을 경우는 명시적으로
왜 계속할 수 없는지 예외를 발생시키라는 것이다. 이 책에서 말하는 계약이란 컴포넌트 간의 통신 중에 반드시 지켜져야 할 몇가지 규칙을 강제하는 것이다.

- 사전조건 -> 함수가 진행되기 전에 체크하는 모든 조건

- 사후조건 -> 함수 반환값의 유효성 검사

- 불변식 -> 함수가 실행되는 동안에 일정하게 유지되는 것

- 부작용 -> 코드의 부작용

### 계약에 의한 디자인이 좋은 이유
사전조건과 사후조건은 코드 레벨에서 체크해야 한다. 이렇게 계약에 의해 디자인을 하는 이유는 오류가 발생할 때 쉽게 찾아낼 수 있기 때문이다. 
사전조건 또는 사후조건 검증에 실패할 경우 오류를 쉽게 찾아서 수정할 수 있다. 뿐만 아니라 잘못된 가정 하에 코드가 실행되는 것을 방지할 수 있다.
이렇게 하면 책임소재를 신속하게 파악할 수 있다. 사전조건 검증이 실패하면 클라이언트의 결함이고 사후조건 검증이 실패하면 특정 모듈이나 제공 클래스의 결함이기
때문이다.

### 사전조건

사전조건이란 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것을 말한다. 파이썬은 동적 타입 언어이기 때문에 전달된 데이터가 적절한 타입인지
확인하는 경우도 있다. 또 처리할 정보에 대해 적절한 유효성 검사를 해야 한다. 사전조건 검증은 클라이언트에서 하거나 함수 자체에 두어야 한다.
중복으로 처리해서는 안된다.

### 사후조건

사후조건이란 메서드 또는 함수가 반환된 후의 상태를 강제하는 것이다. 사후조건을 사용하여 클라이언트가 필요로 하는 모든 것을 검사하고 메서드가
적절히 실행되었다면 계약이 이루어진 것이기 때문에 사후조건 검증에 통과하고 클라이언트는 반환된 객체를 아무 문제없이 사용할 수 있어야 한다.

### 파이썬스러운 계약

파이썬스러운 계약에 있어서 가장 좋은 방법은 메서드, 함수 및 클래스에 RuntimeError 에러 또는 ValueError 예외를 발생시키는 것이다. 또는
적절한 예외를 발생시키기 어렵다면 사용자 정의 예외를 만들어야 한다. 또 사전조건에 대한 검사와 사후조건에 대한 검사 그리고 핵심 기능에 대한
구현을 분리해야 한다.

---

## 2. 방어적 프로그래밍

방어적 프로그래밍은 Dbc(Design by contract)와 다르게 예외를 발생시키고 실패하는 것보다는 객체, 함수 또는 메서드와 같은 코드의 모든 부분을
유효하지 않은 것으로부터 스스로 보호할 수 있게 하는 것이다. 

### 에러 핸들링

오류가 발생하기 쉬운 상황에서 에러 핸들링 프로시저를 사용하는데 일반적으로 데이터 입력 확인 시 자주 사용된다. 에러 핸들링의 주요 목적은 예상되는
에러에 대해서 실행을 계속할 수 있을지 아니면 극복할 수 없는 오류여서 프로그램을 중단할지를 결정하는 것이다.

#### 예외처리 방법
1. 값 대체
2. 에러 로깅
3. 예외 처리

### 1) 값 대체

일부 시나리오에서는 오류가 있어 소프트웨어가 잘못된 값을 생성하거나 전체가 종료될 위험이 있는 경우 값을 안전한 다른 값으로 대체할 수 있다. 기본 값
또는 잘 알려진 상수, 초기 값으로 바꿔 잘못된 결과를 정합성을 깨지 않는 다른 값으로 대체하는 것을 말한다. 하지만 값 대체가 항상 가능하진 않다.
견고성과 정확성 간의 트레이드오프 때문에 예상치 못한 상황에서도 실패하지 않아야 견고하다고 할 수 있지만 실패하지 않는 것이 항상 옳은 것은 아니다.
누락된 데이터를 기본 값으로 바꾸어도 큰 문제가 없지만 오류가 있는 데이터를 유사한 값으로 대체하는 것은 위험하다.

### 2) 예외 처리

잘못되거나 누락된 입력 데이터가 있는 경우 복구 처리가 가능한 경우가 있다. 하지만 어떤 경우에는 에러가 발생하기 쉽다는 가정으로 계속 실행하는 것보다
실행을 멈추는 것이 더 좋다. 호출자에게 실패했음을 알리는 것이 더 좋은 선택이다. 하지만 너무 많은 예외를 발생시키면 호출자가 발생 가능한 모든 부작용을
염두에 두어야 한다. 또 함수가 응집력이 약하고 너무 많은 책임을 가지고 있다는 것을 뜻할 수 있기 때문이다. 파이썬의 예외와 관련된 몇 가지 권장 사항을 
알아보자.

#### 올바른 수준의 추상화 단계에서 예외 처리

예외는 오직 한 가지 일을 하는 함수의 한 부분이어야 한다. 함수가 처리하는 예외는 캡슐화된 로직과 일치해야 한다. 

```python
import requests

url = 'www.google.com'


def bad_example():
    try:
        req = requests.get(url)
        process_data(req.json())
        
    except KeyError:
        print('Key Error')

    except requests.exceptions.ConnectionError:
        print('Connection Error')


def process_data(data):
    print(data['data'])
```

위와 같은 코드를 보면 KeyError와 ConnectionError 예외를 처리하는 것을 알 수 있다. 하지만 두 예외는 관계가 없다. 따라서 책임을 분산해야 할 필요성을
느껴야 한다. ConnectionError는 따로 connection을 담당하는 함수를 만들어 예외를 처리하고 KeyError는 process_data 함수 내에서 처리하면 
해당 함수는 예외를 catch할 필요가 없다. 따라서 함수 안에서 다른 수준의 예외를 처리하고 있다면 적절히 분리하도록 하자.

#### Traceback 노출 금지

예외를 처리할 때 오류가 너무 중요하면 전파해도 괜찮다. 또한 특정 시나리오에서 검토된 내용이거나 견고함보다 정확성이 중요한 상황이라면 프로그램을 종료하게
할 수도 있다. 특정 문제를 나타내는 예외가 있는 경우 문제를 효율적으로 해결할 수 있도록 traceback 정보, 메시지 및 기타 수집 가능한 정보를 로그로 남기는 것이
중요하다. 그러나 세부사항은 사용자에게 보여서는 안된다. 이것은 보안과 관련되어 있고 중요 정보가 유출될 위험이 있기 때문이다. 따라서 사용자에게 문제를
알리려면 무엇이 잘못되었다거나 페이지를 찾을 수 없다는 등의 일반적인 메시지를 사용해야 한다.


#### 비어있는 except 블록 지양

일부 오류에 대비하여 프로그램을 방어하는 것은 좋은 일이지만 너무 방어적인 것은 더 심각한 문제로 이어질 수 있다. 오류를 조용히 지나쳐버리는 비어있는 except
블록은 가장 안 좋은 케이스다. 

```python
try:
    process_data()

except:
    pass
```

위와 같은 코드는 절대 실패하지 않는다. 실패를 반드시 해야 하는 경우에도 에러가 발생하지 않기 때문에 에러를 조용히 전달해서는 안된다는 파이썬의 철학에
어긋난다. 이러한 코드는 문제를 숨기고 유지보수를 더 어렵게 만든다. 따라서 광범위한 예외보다는 구체적인 예외를 사용하고 except 블록에서 실제 오류 처리를
해야 한다.

#### 원본 예외 포함

오류 처리 과정에서 다른 오류를 발생시키고 메시지를 변경할 수도 있다. 이 경우 원래 예외를 포함하는 것이 좋다. 
파이썬에서 raise <e> from <original_exception> 구문을 사용하면 된다.

