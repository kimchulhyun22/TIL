# 2장 파이썬스러운 코드

---

## 1.인덱스와 슬라이스

파이썬은 다른 언어와 마찬가지로 인덱스를 통해 데이터 구조에 접근할 수 있도록 제공한다. 뿐만 아니라 음수 인덱스를 통해 배열의 마지막 요소부터 
접근할 수 있도록 제공한다.

또한 slice를 사용하여 특정 구간의 요소를 구할 수 있다.

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# number1 -> [2, 3, 4]
number1 = numbers[1:4]

# number2 -> [8, 9]
number2 = numbers[-3:-1]

# number3 -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
number3 = numbers[::]

# number4 -> [2, 4, 6, 8, 10]
number4 = numbers[1:10:2]

# number5는 number4와 같다
interval = slice(1, 10, 2)
number5 = numbers[interval]
```

이처럼 튜플, 문자열, 리스트는 특정 요소를 가져오려고 하면 for loop을 이용하기보다는 slice를 이용하는 것이 좋다.

---

## 2. 자체 시퀀스 생성

파이썬에서 인덱스를 사용할 수 있는 이유는 __getitem__이라는 매직 메서드가 존재하기 때문이다. object[key]와 같은 형태를 사용할 때
호출되는 메서드로 파라미터로 key를 전달한다. 시퀀스는 __getitem__과 __len__을 모두 구현하는 객체이므로 반복이 가능하다.

사용자 정의 클래스에 __getitem__을 구현하려는 경우 파이썬스러운 접근 방식을 위해 몇 가지를 고려해야 한다.

```python

class Items:
    def __init__(self, values: list):
        self.values = values

    def __len__(self):
        return len(self.values)

    def __getitem__(self, item):
        return self.values.__getitem__(item)
```
위와 같이 표준 list 객체를 감싼 형태인 경우는 list의 동일한 메서드를 호출하면 된다. 하지만 자신만의 시퀀스를 구현한 경우는 두 가지에 유의해야 한다.


#### 1. 범위로 인덱싱하는 결과는 해당 클래스와 같은 타입의 인스턴스여야 한다.

```python
class Items:
    def __init__(self, *values):
        self.values = values
    
    def __getitem__(self, item):
        return self.values[item]
```
위와 같이 클래스를 구현한 경우 slice를 이용하여 시퀀스를 요청하면 자료형은 self.values의 자료형이 된다. 일반적인 경우 리스트의 일부를 가져오면
리스트이고 스트링에서 substring을 요청하면 스트링이다. 요청 결과는 원본 객체와 동일한 타입이라는 것을 알 수 있다. 

#### 2. slice에 의해 제공된 범위는 파이썬이 하는 것처럼 마지막 요소는 제외해야 한다.
파이썬에서 slice는 마지막 요소를 제외한다. 따라서 예외 케이스를 발생시키지 말고 일관성을 유지하도록 해야 한다.

---

## 3. 컨텍스트 관리자

컨텍스트 관리자는 주요 동작의 전후에 작업을 실행하려고 할 때 유용하다. 예를 들어 파일을 열 때 파일 디스크립터 누수를 막기 위해 작업이 끝나면 적절히
닫히길 기대하고 서비스나 소켓에 대한 연결을 열었을 때도 적절하게 닫거나 임시 파일을 제거하는 등의 작업을 해야 한다. 이런 경우 할당된 리소스를 모두 해제해야
하는데, 예외가 발생하거나 오류를 처리할 경우엔 가능한 모든 조합과 실행 경로를 처리하여 디버깅해야 한다. 예제 1은 일반적인 방법으로 finally를
사용하여 정리 코드를 작성한 것이고, 예제 2는 같은 기능을 파이썬스럽게 구현한 것이다.

예제 1
```python

fd = open('test.txt')

try:
    def process_file(file_name):
        print(file_name)

finally:
    fd.close()
``` 

예제 2
```python

with open('test.txt') as fd:
    def process_file(file_name):
        print(file_name)
        
    process_file(fd)
```

with문은 컨텍스트 관리자로 진입하게 되는데 이는 __enter__와 __exit__ 메소드로 구성된다. with문 진입 시 __enter__메서드를 호출하고 as 이후에
지정된 변수에 할당된다. 그 후 블록으로 구성된 파이썬 코드가 실행되고 종료시에 __exit__ 메서드를 호출한다. 또 블록 내에 예외나 오류가 있는  경우에도
__exit__메서드가 호출되므로 정리 조건을 안전하게 실행할 수 있다.

보통 컨텍스트 관리자는 파일이나 커넥션 등의 리소스 관리에서 자주 사용되는데 이 뿐만 아니라 블록의 전후에 필요로 하는 특정 논리를 제공하기 위해 자체 컨텍스트
관리자를 구현할 수도 있다. 또 컨텍스트 관리자는 관심사를 분리하고 독립적으로 유지되어야하는 코드를 분리하는 좋은 방법이다.

---

## 3. 컨텍스트 관리자 구현

클래스에 __enter__와 __exit__ 매직 메서드만 구현하면 해당 객체는 컨텍스트 관리자 프로토콜을 지원할 수 있다. 함수는 contextlib.contextmanager
데코레이터를 적용하면 해당 함수의 코드를 컨텍스르 관리자로 변환한다. 함수는 제너레이터 형태여야 하고 이 함수는 문장을 __enter__와 __exit__ 매직 메서드로
분리한다.

```python
import contextlib

def start_database():
    print('start database')
    
    
def stop_database():
    print('stop database')
    
    
@contextlib.contextmanager
def db_handler():
    stop_database()

    yield 

    start_database()


with db_handler():
    print('db backup')
```

---

## 4. 프로퍼티, 속성과 객체 메서드의 다른 타입들

public, private, protected 프로퍼티를 가지는 다른 언어들과는 다르게 파이썬 객체의 모든 프로퍼티와 함수는 public이다. 따라서 호출자가
객체의 속성을 호출하지 못하도록 할 방법이 없다. 따라서 강제할 순 없지만 규칙은 있는데 대표적으로 밑줄로 시작하는 속성은 해당 객체에 대해 private으로
간주한다는 것이 있다.


### 파이썬에서의 밑줄

파이썬에서는 모든 객체의 속성은 public이다. 따라서 밑줄 규칙을 통해서 구분해야 한다.

```python
class Connector:
    def __init__(self, source):
        # public
        self.source = source
        
        # private
        self._timeout = 60
```

하지만 밑줄을 통해 속성과 메서드를 실제로 private으로 만들 수 있다는 오해를 하는 경우가 있다. 하지만 이것은 이름 맹글링이라 한다.
_{클래스 이름}__{속성 이름}의 이름으로 속성이 만들어진다.

```python
class Connector:
    def __init__(self, source):
        self.source = source
        self.__timeout = 60
```
위의 코드는 _Connector__timeout이라는 속성이 만들어진다. 따라서 Connector 객체의 __timeout 속성을 접근할 경우 AttributeError가
발생한다. 

파이썬에서 이중 밑줄을 사용하는 것은 여러 번 확장되는 클래스의 메서드를 이름 충돌 없이 오버라이드하기 위해 만들어졌다.

### 프로퍼티

객체에 값을 저장하거나 읽으려고 하는 경우에는 프로퍼티를 사용하는 것이 좋다.

```python

class User:
    def __init__(self, name, email):
        self.name = name
        self._email = email
    
    @property
    def email(self):
        return self._email    
    
    @email.setter
    def email(self, email):
        self._email = email
```
파이썬에서는 밑줄로 시작하는 변수는 외부에서 접근하지 않는다는 규칙이 있어서 email값은 직접 접근하지 않고 property를 만들어서 구현하는 것이 좋다.
또 get_, set_ 접두어를 사용하여 사용자 메서드를 만드는 것보다 훨씬 더 간단하다.

프로퍼티는 명령-쿼리 분리 원칙을 따르기 위한 좋은 방법이기도 하다. @property 데코레이터는 무언가에 응답하기 위한 쿼리이고, @{property_name}.setter
는 무언가를 하기 위한 커맨드이다. 따라서 if self.set_email("a@j.com")처럼 이메일을 설정하려는 건지 잘 설정되었는지 확인하려는지 이해하기
어려운 경우를 방지할 수 있다.

---

## 5. 이터러블 객체

파이썬에서는 리스트, 튜플, 세트 등 원하는 데이터의 구조를 보유하고 for 루프를 통해 값을 반복적으로 가져올 수 있는 자료형들이 있다.
하지만 이런 자료형 말고도 자체 이터러블을 만들 수 있다. 이터러블은 __iter__ 매직 메서드를 구현한 객체, 이터레이터는 __next__ 매직 메서드를
구현한 객체이다. 파이썬의 반복은 이터러블 프로토콜이라는 자체 프로토콜을 사용해 동작하는데 두 가지를 차례로 검사한다.

1. 객체가 __next__나 __iter__ 이터레이터 메서드 중 하나를 포함하는지 여부
2. 객체가 시퀀스이고 __len__과 __getitem__를 모두 가졌는지 여부

### 이터러블 객체 만들기

객체를 반복하려고 하면 파이썬은 해당 객체의 iter() 함수를 호출한다. 이 함수가 처음으로 하는 것은 해당 객체에 __iter__ 메서드가 있는지를 확인하고
있으면 실행한다.

```python
from datetime import timedelta, date


class DateRangeIterable:
    def __init__(self, start_date, end_date):
        self.start_date = start_date
        self.end_date = end_date
        self._present_day = start_date

    def __iter__(self):
        return self

    def next(self):
        if self._present_day >= self.end_date:
            raise StopIteration

        today = self._present_day
        self._present_day += timedelta(days=1)

        return today


for day in DateRangeIterable(date(2019, 1, 1), date(2019, 1, 5)):
    print(day)
```

for 루프는 앞서 만든 객체를 사용해 반복을 한다. 파이썬은 iter() 함수를 호출할 것이고, 이 함수는 __iter__ 매직 메서드를 호출할 것이다.
__iter__ 메서드는 self를 반환하고 있으므로 객체 자신이 이터러블임을 나타낸다. 그리고 루프의 각 단계마다 next 메서드를 호출한다. 루프가
조건을 만족하여 종료해야할 경우는 StopIteration 예외를 발생시킨다. 즉 for 루프가 작동하는 원리는 StopIteration 예외가 발생할 때까지
next()를 호출하는 것과 같다.

하지만 위의 코드는 반복을 하고 다시 반복을 하면 바로 종료될 것이다. __iter__에서 self 객체를 반환하기 때문이다. 따라서 __iter__에서 제너레이터를
사용하여 해결할 수 있다.

```python
from datetime import timedelta


class DateRangeContainerIterable:
    def __init__(self, start_date, end_date):
        self.start_date = start_date
        self.end_date = end_date
    
    def __iter__(self):
        current_day = self.start_date
        while current_day < self.end_date:
            yield current_day
            current_day += timedelta(days=1)

```

### 시퀀스 만들기

iter() 함수는 객체에 __iter__가 정의되어 있지 않으면 __getitem__을 찾고 없으면 TypeError를 발생시킨다. 
__getitem__을 구현할 때는 첫 번째 인덱스부터 시작하여 포함된 요소를 하나씩 차례로 잘 가져올 수 있도록 올바르게 구현하여야 한다. 그렇지 않으면
반복이 작동하지 않는다. 이터러블 객체를 생성하여 반복하는 경우는 메모리가 적게 들지만 n번째 요소에 접근하기 위해서는 n번 반복해야 한다. 하지만
이전에 공부했던 시퀀스를 생성해서 반복하는 경우에는 n번째 요소에 바로 접근할 수 있다.

---

## 6. 컨테이너 객체

컨테이너는 __contains__ 메서드를 구현한 객체로 __contain__ 메서드는 일반적으로 Boolean 값을 반환한다. 이 메서드는 in 키워드가 발견되면 호출된다.
element in container 같은 코드가 예시다. 

```python
class Boundary:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def __contains__(self, coord):
        x, y = coord
        return 0 <= x < self.width and 0 <= y < self.height

```
---

## 7. 객체의 동적인 속성

{object}.{attribute}를 호출하면 파이썬은 객체의 사전에서 attribute를 찾아서 __getattribute__를 호출한다. 만약 속성이 없는 경우는
속성 이름을 파라미터로 전달하여 __getattr__이라는 추가 메서드를 호출한다. __getattr__같은 동적 메서드를 구현할 때는 AttributeError를 
발생시켜야 한다.

---

## 8. 호출형 객체

함수처럼 동작하는 객체를 정의하면 데코레이터를 만드는 것처럼 편한 상황이 많다. __call__ 매직 메서드를 구현하면 객체를 일반 함수처럼 호출할
수 있다. 

```python
class CallObject:
    def __init__(self):
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        return self.count


c = CallObject()
print(c(1))


@call_object
def test_call():
    print('test call')


print(test_call)
```
객체를 호출할 수 있도록 하게 되면 데코레이터에도 이용할 수 있다.


