# 5. 데코레이터를 사용한 코드 개선

---

## 1. 파이썬의 데코레이터

파이썬에서 데코레이터는 classmethod나 staticmethod 같은 함수가 원래 메서드의 정의를 변형하는데 사용되고 있었기 때문에 고안된 수단인데 이런 방법은
추가 코드가 필요하고 함수의 원래 정의를 수정해야만 했다. 즉, 함수에 변형을 할 때마다 modifier 함수를 사용하여 함수를 호출한 다음 함수를 처음 정의한 것과
같은 이름으로 재할당해야 했다.

```python
def original():
    pass

def modifier(original):
    pass

original = modifier(original)
```

이렇게 되면 함수를 재할당하는 것을 잊어버리거나 실수를 할 가능성이 높아서 데코레이터라는 새로운 구문이 추가되었다.

```python

def modifier(original):
    pass

@modifier
def original():
    pass
```

데코레이터는 데코레이터 이후에 나오는 것을 데코레이터의 첫 번째 파라미터로 하고 데코레이터의 결과 값을 반환하게 한다. 위의 예제에서는 modifier를 데코레이터
라 하고 original을 데코레이팅된 함수 또는 래핑된 객체라 한다.

### 함수 데코레이터

함수에 데코레이터를 사용하면 어떤 종류의 로직이라도 적용할 수 있다.

예를 들면,

- 파라미터 유효성 검사
- 사전조건 검사
- 새로운 기능 정의
- 서명 변경
- 원래 함수의 결과 캐시

### 클래스 데코레이터

클래스 데코레이터도 함수 데코레이터와 클래스를 파라미터로 전달한다는 것 외에는 동일하게 작동한다. 클래스 데코레이터를 남용할 경우 복잡하고 가독성을 떨어뜨릴 수
있지만 우선 클래스 데코레이터의 장점만 파악한다.

#### 클래스 데코레이터의 장점

- 클래스 데코레이터는 코드 재사용과 DRY 원칙의 모든 이점을 공유한다
- 먼저 작고 간단한 클래스를 생성하고 나중에 데코레이터로 기능을 보강할 수 있다
- 어떤 클래스에 대해서는 유지보수 시 데코레이터를 사용해 기존 로직을 훨씬 쉽게 변경할 수 있다.

### 다른 유형의 데코레이터

데코레이터는 함수나 클래스 뿐만 아니라 제너레이터나 코루틴, 이미 데코레이트된 객체도 데코레이트 가능하고, 스택 형태로 쌓일 수 있다. 
즉 어떤 함수에 데코레이터가 여러 개 있는 경우, 함수와 가장 가까운 데코레이터부터 처리된다.

### 데코레이터에 인자 전달

#### 중첩 함수의 데코레이터

데코레이터는 함수를 파라미터로 받아서 함수를 반환하는 함수이다. 이런 함수를 고차 함수라고 부른다. 데코레이터를 파라미터에 전달하려면 다른 수준의 간접 참조가
필요하다. 첫 번째 함수는 파라미터를 받아서 내부 함수에 전달한다. 두 번째 함수는 데코레이터가 될 함수다. 세 번째는 데코레이팅의 결과를 반환하는 함수다.

```python
RETRIES_LIMIT = 3

def with_retry(retries_limit=RETRIES_LIMIT, allowed_exceptions=None):
    
    def retry(operation):
        
        def wrapped(*args, **kwargs):
            last_raised = None
            
            for _ in range(retries_limit):
                try:
                    return operation(*args, **kwargs)
                
                except allowed_exceptions as e:
                    print(e)
                    last_raised = e
            
            raise  last_raised
        
        return wrapped
    
    return retry


@with_retry()
def run_operation(task):
    return task.run()

```

위와 같은 코드는 <original_function> = @retry(arg1, arg2, ...)(<original_function>)의 형태가 된다.

#### 데코레이터 객체

위에서 중첩 함수로 데코레이터에 파라미터를 전달하는 경우보다 클래스를 사용하여 데코레이터를 정의하면 조금 더 깔끔하게 구현할 수 있다.

```python
RETRIES_LIMIT = 3

class WithRetry:
    def __init__(self, retries_limit=RETRIES_LIMIT, allowed_exceptions=None):
        self.retries_limit = retries_limit
        self.allowed_exceptions = allowed_exceptions
    
    def __call__(self, operation):
        def wrapper(*args, **kwargs):
            last_raised = None
            
            for _ in range(self.retries_limit):
                 try:
                     return operation(*args, **kwargs)
                 
                 except self.allowed_exceptions as e:
                     last_raised = e
            
            return last_raised
        
        return wrapper
    
@WithRetry(retries_limit=5)
def run_operation(task):
    return task.run()

```

### 데코레이터 활용 우수 사례

#### 파라미터 변환

데코레이터를 사용하여 파라미터의 유효성을 검사할 수 있다. 디자인에 의한 설계에 따라 사전조건 또는 사후조건을 강제할 수 있다. 데코레이터를 통해
유사한 객체를 반복적으로 생성하거나 추상화를 위해 유사한 변형을 반복하는 경우에 쉽게 처리할 수 있다.

#### 코드 추적

다음과 같은 상황에서 함수의 실행과 관련된 정보를 추적할 수 있다.
1. 실제 함수의 실행 경로 추적 ex) 실행 함수 로깅
2. 함수 지표 모니터링 ex) CPU 사용률, 메모리 사용량
3. 함수의 실행시간 추적
4. 언제 함수가 실행되고 전달된 파라미터는 무엇인지 로깅

---

## 2. 데코레이터의 활용 - 흔한 실수 피하기

파이썬 데코레이터는 훌륭한 기능이지만 잘못 사용했을 경우 발생하는 문제에 있어서는 예외가 아니다. 따라서 효과적인 데코레이터를 만들기 위해 피해야할 것들은
피해야 한다.

### 래핑된 원본 객체의 데이터 보존

데코레이터를 함수에 적용할 때 가장 많이 실수하는 것 중에 하나는 원본 함수의 일부 프로퍼티나 또는 속성을 유지하지 않아 원하지 않는 부작용을 유발한다는 것이다.

```python
from functools import wraps


def trace_decorator(function):
    @wraps(function)
    def wrapper(*args, **kwargs):
        print("{} 실행".format(function.__qualname__))
        return function(*args, **kwargs)

    return wrapper


@trace_decorator
def process_account(account_id):
    """
        id별 계정 처리
    :param account_id:
    :return:
    """
    print("{} 계정 처리".format(account_id))



process_account('tom')
print(help(process_account))

```
데코레이터는 원래 함수의 어떤 것도 변경하지 않아야 하지만 코드에 결함이 있어서 이름이나 docstring을 변경하는 경우가 있다. 위의 wrapper 함수 위의 wraps
데코레이터를 생략하면 wrapper 함수가 원본 함수를 래핑한 것이라고 알 수 없기 때문에 process_account 함수의 정보를 변경한다.

### 데코레이터 부작용 처리

데코레이터 함수가 되기 위해 필요한 하나의 조건은 가장 안쪽에 정의된 함수여야 한다는 것이다. 그렇지 않으면 임포트에 문제가 발생할 수 있다. 그럼에도 불구하고
떄로는 임포트 시에 실행하기 위해 이러한 부작용이 필요한 경우도 있고 반대의 경우도 있다.

#### 데코레이터 부작용의 잘못된 처리

```python
import time
from functools import wraps

def trace_function(function):
    print("{} 함수 실행".format(function))
    start_time = time.time()
    
    @wraps(function)
    def wrapper(*args, **kwargs):
        print("함수 {}의 실행시간 : ".format(function, time.time() - start_time))
        
@trace_function
def process_with_delay(callback, delay=0):
    time.sleep(delay)
    return callback()
```

위의 코드는 같은 기능을 여러 번 호출하면 같은 기능이지만 함수의 실행시간이 점점 더 오래걸리는 것처럼 결과가 나올 것이다. 
이 코드가 임포트되면 process_with_delay = trace_function(process_with_delay) 구문이 실행된다. 따라서 임포트만 해도 함수의 시작 시간이
로그로 남는 것이다. 이 버그를 해결하기 위해선 구문을 모두 래핑 함수 안으로 넣으면 된다.

#### 데코레이터 부작용의 활용

데코레이터의 부작용을 의도적으로 사용하여 실제 실행이 가능한 시점까지 기다리지 않는 경우가 있다. 대표적으로 모듈의 공용 레지스트리에 객체를 등록하는 경우가
있다.
```python

EVENTS_REGISTRY = {}


def register_event(event_cls):
    EVENTS_REGISTRY[event_cls.__name__] = event_cls
    return event_cls


class Event:
    pass


class UserEvent:
    pass

@register_event
class UserLoginEvent(UserEvent):
    pass

@register_event
class UserLogoutEvent(UserEvent):
    pass

```

### 어느 곳에서나 동작하는 데코레이터 만들기

데코레이터를 함수나 클래스, 메서드 또는 정적 메서드 등 여러 곳에 재사용하려는 경우가 있다. 보통 데코레이터를 만들면 장식하고 싶은 첫 번째 유형의 객체만을
지원하려고 생각한다. 그러나 같은 데코레이터를 다른 유형에 적용하려고 하면 오류가 발생한다는 것을 알 수 있다. 대표적인 예로 함수에 사용될 데코레이터를 클래스의
메서드에 적용하려는 경우이다. 메서드에 대한 데코레이터를 디자인한 다음 유사한 메서드 또는 클래스 메서드에도 적용하려는 경우에도 마찬가지다. 

따라서 재사용을 고려하여 함수 뿐 아니라 메서드에서도 동작하도록 데코레이터를 만들기 위해 *args와 **kwargs 서명을 사용하여 데코레이터를 정의한다. 하지만
원래 함수의 서명과 비슷하게 데코레이터를 정의하는 것이 좋을 때가 있다.

1. 원래의 함수와 모양이 비슷하기 때문에 읽기가 쉽다.
2. 파라미터를 받아서 뭔가를 하려면 *args와 **kwargs를 사용하는 것이 불편하다.

---

## 3. 데코레이터와 DRY 원칙

데코레이터를 사용하여 특정 로직을 분리된 컴포넌트로 추상화하는 방법을 사용하면 여러 객체에 데코레이터를 적용하여 코드를 재사용할 수 있다는 것이다. 특정 기능을
한 번만 정의하기 때문에 DRY(Do not Repeat Yourself) 원칙을 잘 따른다. 데코레이터를 재사용하여 여러 클래스에 적용할 수 있기 때문에 추가적인 개발 비용
과 복잡도가 충분한 가치를 가진다. 또 코드 재사용을 위해 데코테이터를 사용할 때 실질적으로 코드 사용량을 줄일 수 있다는 믿음이 있어야 한다. 

하지만 모든 데코레이터, 특히 신중하게 설계되지 않은 데코레이터는 코드의 복잡성을 증가시킨다. 재사용할 필요가 없을 경우 별개의 함수나 작은 클래스로도 충분하다.

데코레이터를 적용하기 위한 고려사항
1. 처음부터 데코레이터를 만들지 않는다. 패턴이 생기고 데코레이터에 대한 추상화가 명확해지면 그 때 리팩토링을 한다.
2. 데코레이터가 적어도 3회 이상 필요한 경우에만 구현한다.
3. 데코레이터 코드를 최소한으로 유지한다.


---

## 4. 데코레이터와 관심사의 분리

코드 재사용의 핵심은 응집력이 있는 컴포넌트를 만드는 것이다. 즉 최소한의 책임을 가져서 오직 한 가지 일만 해야 하며, 그 일을 잘 해야 한다. 컴포넌트가
작을수록 재사용성이 높아진다. 그리고 결합과 종속성을 유발하고 소프트웨어의 유연성을 떨어뜨리는 추가 동작이 필요 없이 여러 상황에서 쓰일 수 있다.

---

## 5. 좋은 데코레이터 분석

좋은 데코레이터가 갖춰야할 특성
1. 캡술화와 관심사의 분리 -> 실제로 하는 일과 데코레이팅하는 일의 책임을 명확히 분리하여 어설픈 추상화를 하면 안된다
2. 독립성 -> 데코레이터가 하는 일은 독립적이어야 하며 데코레이팅되는 객체와 최대한 분리되어야 한다.
3. 재사용성 -> 여러 유형에 적용 가능한 형태가 바람직하다.

좋은 데코레이터는 깔끔한 인터페이스를 제공하고 사용자가 내부 동작 원리를 자세히 몰라도 기대하는 바를 정확히 알 수 있게 해준다.


