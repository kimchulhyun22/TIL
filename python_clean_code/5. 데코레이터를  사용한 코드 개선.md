# 5. 데코레이터를 사용한 코드 개선

---

## 1. 파이썬의 데코레이터

파이썬에서 데코레이터는 classmethod나 staticmethod 같은 함수가 원래 메서드의 정의를 변형하는데 사용되고 있었기 때문에 고안된 수단인데 이런 방법은
추가 코드가 필요하고 함수의 원래 정의를 수정해야만 했다. 즉, 함수에 변형을 할 때마다 modifier 함수를 사용하여 함수를 호출한 다음 함수를 처음 정의한 것과
같은 이름으로 재할당해야 했다.

```python
def original():
    pass

def modifier(original):
    pass

original = modifier(original)
```

이렇게 되면 함수를 재할당하는 것을 잊어버리거나 실수를 할 가능성이 높아서 데코레이터라는 새로운 구문이 추가되었다.

```python

def modifier(original):
    pass

@modifier
def original():
    pass
```

데코레이터는 데코레이터 이후에 나오는 것을 데코레이터의 첫 번째 파라미터로 하고 데코레이터의 결과 값을 반환하게 한다. 위의 예제에서는 modifier를 데코레이터
라 하고 original을 데코레이팅된 함수 또는 래핑된 객체라 한다.

### 함수 데코레이터

함수에 데코레이터를 사용하면 어떤 종류의 로직이라도 적용할 수 있다.

예를 들면,

- 파라미터 유효성 검사
- 사전조건 검사
- 새로운 기능 정의
- 서명 변경
- 원래 함수의 결과 캐시

### 클래스 데코레이터

클래스 데코레이터도 함수 데코레이터와 클래스를 파라미터로 전달한다는 것 외에는 동일하게 작동한다. 클래스 데코레이터를 남용할 경우 복잡하고 가독성을 떨어뜨릴 수
있지만 우선 클래스 데코레이터의 장점만 파악한다.

#### 클래스 데코레이터의 장점

- 클래스 데코레이터는 코드 재사용과 DRY 원칙의 모든 이점을 공유한다
- 먼저 작고 간단한 클래스를 생성하고 나중에 데코레이터로 기능을 보강할 수 있다
- 어떤 클래스에 대해서는 유지보수 시 데코레이터를 사용해 기존 로직을 훨씬 쉽게 변경할 수 있다.

### 다른 유형의 데코레이터

데코레이터는 함수나 클래스 뿐만 아니라 제너레이터나 코루틴, 이미 데코레이트된 객체도 데코레이트 가능하고, 스택 형태로 쌓일 수 있다. 
즉 어떤 함수에 데코레이터가 여러 개 있는 경우, 함수와 가장 가까운 데코레이터부터 처리된다.

### 데코레이터에 인자 전달

#### 중첩 함수의 데코레이터

데코레이터는 함수를 파라미터로 받아서 함수를 반환하는 함수이다. 이런 함수를 고차 함수라고 부른다. 데코레이터를 파라미터에 전달하려면 다른 수준의 간접 참조가
필요하다. 첫 번째 함수는 파라미터를 받아서 내부 함수에 전달한다. 두 번째 함수는 데코레이터가 될 함수다. 세 번째는 데코레이팅의 결과를 반환하는 함수다.

```python
RETRIES_LIMIT = 3

def with_retry(retries_limit=RETRIES_LIMIT, allowed_exceptions=None):
    
    def retry(operation):
        
        def wrapped(*args, **kwargs):
            last_raised = None
            
            for _ in range(retries_limit):
                try:
                    return operation(*args, **kwargs)
                
                except allowed_exceptions as e:
                    print(e)
                    last_raised = e
            
            raise  last_raised
        
        return wrapped
    
    return retry


@with_retry()
def run_operation(task):
    return task.run()

```

위와 같은 코드는 <original_function> = @retry(arg1, arg2, ...)(<original_function>)의 형태가 된다.

#### 데코레이터 객체

위에서 중첩 함수로 데코레이터에 파라미터를 전달하는 경우보다 클래스를 사용하여 데코레이터를 정의하면 조금 더 깔끔하게 구현할 수 있다.

```python
RETRIES_LIMIT = 3

class WithRetry:
    def __init__(self, retries_limit=RETRIES_LIMIT, allowed_exceptions=None):
        self.retries_limit = retries_limit
        self.allowed_exceptions = allowed_exceptions
    
    def __call__(self, operation):
        def wrapper(*args, **kwargs):
            last_raised = None
            
            for _ in range(self.retries_limit):
                 try:
                     return operation(*args, **kwargs)
                 
                 except self.allowed_exceptions as e:
                     last_raised = e
            
            return last_raised
        
        return wrapper
    
@WithRetry(retries_limit=5)
def run_operation(task):
    return task.run()

```

### 데코레이터 활용 우수 사례

#### 파라미터 변환

데코레이터를 사용하여 파라미터의 유효성을 검사할 수 있다. 디자인에 의한 설계에 따라 사전조건 또는 사후조건을 강제할 수 있다. 데코레이터를 통해
유사한 객체를 반복적으로 생성하거나 추상화를 위해 유사한 변형을 반복하는 경우에 쉽게 처리할 수 있다.

#### 코드 추적

다음과 같은 상황에서 함수의 실행과 관련된 정보를 추적할 수 있다.
1. 실제 함수의 실행 경로 추적 ex) 실행 함수 로깅
2. 함수 지표 모니터링 ex) CPU 사용률, 메모리 사용량
3. 함수의 실행시간 추적
4. 언제 함수가 실행되고 전달된 파라미터는 무엇인지 로깅