# 6장 작업 단위 패턴

작업 단위 패턴은 원자적 연산이라는 개념의 추상화이다.

---

## Uow(Unit of Work)

UoW가 없는 경우 API는 DB 세션과 Repository를 생성하여 서비스 함수를 호출하므로 총 3가지 계층과 대화한다. 하지만 UoW를 통해 API는 UoW 객체를 생성하여 서비스 함수만 호출하면 된다. 따라서 API와 서비스 함수는 데이터베이스와 직접 연결되지 않고 UoW를 통해 데이터베이스와 연결된다.

## 작업 단위는 저장소와 협력

다음은 UoW을 이용하는 서비스 계층의 코드이다.

```python
def allocate(orderid: str, sku: str, qty:int, uow:unit_of_work.AbstractUnitOfWork) -> str:
    line = OrderLine(orderid, sku, qty)

    with uow:
        batches = uow.batches.list()

        batchref = model.allocate(line, batches)

        uow.commit()
```

UoW는 영속적 저장소에 대한 단일 진입점으로 작용한다. 따라서 어떤 객체가 메모리에 적재됐고 어떤 객체가 최종 상태인지를 기억한다. 

UoW를 통해 얻을 수 있는 장점
1. 작업에 사용할 데이터베이스의 안정적인 스냅샷을 제공하고 연산을 진행하는 과정에서 변경하지 않은 객체에 대한 스냅샷도 제공한다.
2. 변경 내용을 한번에 영속화할 방법을 제공한다. 어딘가 잘못되더라도 일관성이 없는 상태로 끝나지 않는다. 
3. 영속성을 처리하기 위한 간단한 API와 저장소를 쉽게 얻을 수 있는 장소를 제공한다.

---

## UoW를 서비스 계층에 사용하기

```python

def add_batch(ref: str, sku: str, qty: int, eta: Optional[date], uow: unit_of_work.AbstractUnitOfWork):
    with uow:
        uow.batches.add(model.Batch(ref, sku, qty, eta))
        uow.commit()


def allocate(orderid: str, sku: str, qty: int,  uow:unit_of_work.AbstractUnitOfWork) -> str:

    with uow:
        batches = uow.batches.list()

        if not is_valid_sku(line.sku, batches):
            raise InvalidSku(f'Invalid  sku {line.sku}')

        batchref = model.allocate(line, batches)
        uow.commit()

    return batchref
```

이렇게 되면 서비스 계층의 의존성은 UoW 추상화 하나뿐이다.

---

## 명시적 커밋과 암시적 커밋

```python
class AbstractUnitOfWork(abc.ABC):
    def __enter__(self):
        return self
    
    def __exit__(self, exn_type, exn_value, traceback):
        if exn_type is None:
            self.commit()
        else:
            self.rollback()
```


