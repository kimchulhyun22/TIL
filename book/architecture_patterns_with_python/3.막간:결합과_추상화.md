# 3. 막간: 결합과 추상화

## 결합

**결합**이란 B 컴포넌트가 깨지는 게 두려워서 A 컴포넌트를 변경할 수 없는 경우 이 두 컴포넌트가 결합되어 있다고 할 수 있다.

**지역적인 결합**은 코드가 서로 함께 작동하고 한 컴포넌트가 다른 컴포넌트를 지원하며 서로 맞물려 돌아간다는 것이다. 이러한 경우에 응집이 있다고 표현할 수 있다.

하지만 **전역적인 결합**은 코드를 변경하는 데 드는 비용을 증가시키고 점점 커져서 코드를 변경할 수 없는 지경에 이르기도 한다. 진흙 공 패턴의 문제가 이와 같다고 할 수 있다.

이러한 결합 사이에 추상화를 중간에 추가한다면 결합 수준을 낮출 수 있다. A 컴포넌트와 B 컴포넌트 사이의 결합에 추상화를 추가하게 되면 각 컴포넌트의 세부 사항을 추상화가 감춰주기 때문에 각 컴포넌트의 변경으로부터 사용자를 보호한다.

---

## 추상화

저수준 세부 사항의 코드를 고수준의 코드로 분리하는 것을 추상화라고 볼 수 있다. 함수 안에 많은 부분이 저수준 코드로 작성되어 있다면 같은 개념의 저수준 코드를 모아 고수준의 코드로 분리해야 테스트가 용이해지고 확장성이 좋아진다.

예를 들어, 
```python
import hashlib
import os
import shutil
from pathlib import Path


def sync(source, desination):
    # 원본 폴더의 자식들을 순회하면서 파일 이름과 해시의 사전을 만든다.
    source_hashes = {}
    for folder, _, files in os.walk(source):
        for fn in files:
            source_hashes[hash_file(Path(folder)) / fn] = fn

    seen = set()

    # 사본 폴더 자식들을 순회하면서 파일 이름과 해시를 얻는다.
    for folder, _, files in os.walk(destination):
        for fn in files:
            dest_path = Path(folder) / fn
            dest_hash = hash_file(dest_path)
            seen.add(dest_hash)

            # 사본에는 있지만 원본에는 없는 파일을 찾으면 삭제한다.
            if dest_hash not in source_hashes:
                dest_path.remove()
    
            # 사본에 있는 파일이 원본과 다른 이름이라면
            # 사본 이름을 올바른 이름으로 바꾼다
            elif dest_hash in source_hashes and fn != soruce_hashes[dest_hash]:
                shutile.move(dest_path, Path(folder) / source_hashes[dest_hash])

    # 원본에는 있지만 사본에 없는 모든 파일을 사본으로 복사한다.
    for src_hash, fn in source_hashes.items():
        if src_hash not in seen:
            shutils.copy(Path(source) / fn, Path(destination) / fn)
```

위와 같은 코드는 "**두 디렉터리의 차이 알아내기**"라는 도메인 로직이 I/O 코드와 긴밀히 결합되어 있다고 할 수 있다. 이러한 경우에는 테스트를 하기 위해 준비 과정이 많이 필요하고 확장성이 좋지 않다.

따라서 다음과 같이 책임을 분리하여 추상화해야 한다.
1. os.walk를 사용해 파일 시스템 정보를 얻고, 얻은 파일 경로로부터 파일 내용의 해시를 결정한다.
2. 파일이 새 파일인지, 이름이 변경된 파일인지, 중복된 파일인지 결정한다.
3. 원본과 사본을 일치시키기 위해 파일을 복사하거나 옮기거나 삭제한다.

이런 추상화를 구현하기 위해서는 실제 파일 시스템 없이도 테스트할 수 있고 외부 상태에 대해 아무 의존성이 없는 코드를 작성해야 한다. 

```python
def sync(source, destination):
    # 입력 수집
    source_hashes = read_paths_and_hashes(source)
    destination_hashes = read_paths_and_hashes(destination)

    # 함수형 핵 호출
    actions = determine_actions(source_hashes, destination_hashes, source, destination)

    # 출력 적용
    for action, *paths in actions:
        if action == 'copy':
            shutil.copyfile(*paths)
        if action == 'move':
            shutil.move(*paths)
        if action == 'delete':
            os.remove(paths[0])
```

위와 같이 코드를 작성하면 애플리케이션의 I/O 부분을 격리할 수 있고 핵심 비즈니스 로직을 분리할 수 있다.
따라서 단위 테스트 시 비즈니스 로직에 해당하는 함수형 핵부분을 쉽게 테스트할 수 있다. 뿐만 아니라 의존성 주입을 통해 덩어리 테스트보다는 Edge To Edge 테스트도 수행할 수 있게 된다.