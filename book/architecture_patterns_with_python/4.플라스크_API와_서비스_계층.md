# 4장 첫 번째 유스 케이스: 플라스크 API와 서비스 계층

**서비스 계층**에서는 워크플로를 조정하고 시스템의 유스 케이스를 정의한다.

---

## 애플리케이션 구현

정의된 도메인 모델을 애플리케이션으로 구현하기 위해서는 다음과 같은 과정이 필요하다.

1. 플라스크를 사용해 allocate 도메인 서비스 앞에 API 엔드포인트를 위치한다.
2. 서비스 계층을 리팩터링해서 플라스크와 도메인 모델 사이에 유스 케이스를 담는 추상화 역할을 할 수 있게 한다.
3. 서비스 계층의 기능을 여러 유형의 파라미터로 테스트한다.

아래와 같은 엔드포인트 함수를 살펴보자.

```python
def is_valid_sku(sku, batches):
    return sku in {b. sku for b in batches}


@app.route("/allocate", methods=['POST'])
def allocate_endpoint():
    session = get_session()
    batches = repository.SqlAlchemyRepository(session).list()
    line = model.OrderLine(
        request.json['orderid'],
        request.json['sku'],
        request.json['qty']
    )

    if not is_valid_sku(line.sku, batches):
        return jsonify({'message': f'Invalide sku {line.sku}'}), 400
    
    try:
        batchref = model.allocate(line, batches)
    except model.OutOfStock as e:
        return jsonify({{'message': str(e)}}), 400

    session.commit()
    return jsonify({'batchref': batchref}), 201
```

다음 테스트 코드를 작성해보자

```python
@pytest.mark.usefixtures('restart_api')
def test_allocations_are_persisted(add_stock):
    sku = random_sku()
    batch1, batch2 = random_batchref(1), random_batchref(2)
    order1, order2 = random_orderid(1), random_orderid(2)
    add_stock([
        (batch1, sku, 10, '2011-01-01'),
        (batch2, sku, 10, '2011-01-02')
    ])

    line1 = {'orderid': order1, 'sku': sku, 'qty': 10}
    line2 = {'orderid': order2, 'sku': sku, 'qty': 10}
    
    # 첫 번째 주문은 배치 1에 있는 모든 재고를 소진
    r = requests.post(f'{url}/allocate', json=line1)
    assert r.status_code == 201
    assert r.json()['batchref'] == batch1

    # 두 번째 주문은 배치 2로 가야 함
    r = requests.post(f'{url}allocate', json=line2)
    assert r.status_code == 201
    assert r.json()['batchref'] == batch2
```

기능과 요구 사항이 복잡해 질수록 API 엔드포인트 함수와 테스트 코드가 점점 더 복잡해지고, 불필요한 API Call의 유효성을 점검해야 한다. 

플라스크 앱이 하는 일을 보면 웹 API 엔드포인트와는 관련없는 저장소에서 데이터를 가져오고, 데이터베이스 상태에 따라 입력을 검증하며 오류를 처리하고, 성공적인 경우 데이터를 데이터베이스에 커밋하는 작업에 해당하는 **오케스트레이션**이 상당 부분을 차지한다.

이런 오케스트레이션은 엔드 투 엔드 테스트에서 테스트해야 할 대상이 아니다. 따라서 테스트를 할 때는 가짜 저장소를 이용하고 웹 관련 로직들은 생략하고 테스트를 하는 것이 가장 좋다.

따라서 전형적인 서비스 계층 함수들은 다음과 같은 단계를 거친다.
1. 저장소에서 어떤 객체들을 가져온다.
2. 현재 세계를 바탕으로 요청을 검사하거나 어서션으로 검증한다.
3. 도메인 서비스를 호출한다.
4. 모든 단계가 정상적으로 실행됐다면 변경한 상태를 저장하거나 업데이트한다.
   
---

## 도메인 서비스와 애플리케이션 서비스(서비스 계층)의 차이

### 1. 애플리케이션 서비스(서비스 계층)

서비스 계층은 외부 세계에서 오는 요청을 처리해 연산을 오케스트레이션한다.
1. 데이터베이스에서 데이터를 얻는다
2. 도메인 모델을 업데이트한다
3. 변경된 내용을 영속화한다

### 2. 도메인 서비스

도메인 서비스는 도메인 모델에 속하지만 근본적으로 상태가 있는 엔티티나 값 객체에 속하지 않는 로직을 부르는 이름이다. 

ex) 쇼핑 카트 애플리케이션의 경우 세금 관련 규칙을 구현

세금을 계산하는 작업은 쇼핑 카트를 업데이트하는 것과는 별개이고 모델에서 중요하지만 세금만을 위한 영속적인 엔티티를 사용하는 것은 바람직하지 않다.

---

## 프로젝트 디렉토리 구조

애플리케이션이 커짐에 따라 디렉토리 구조를 깔끔하게 다듬을 필요가 있다. 디렉토리는 다음과 같이 조직화할 수 있다.

- config.py
- domain
  - __init__.py
  - model.py
- service_layer
  - __init__.py
  - services.py
- adapters
  - __init__.py
  - orm.py
  - repository.py
- entrypoints
  - __init__.py
  - flask_app.py
- tests
  - __init__.py
  - conftest.py
  - unit
    - test_allocate.py
    - test_batches.py
    - test_services.py
  - integration
    - test_orm.py
    - test_repository.py
  - e2e
  - test_api.py