# 2. 저장소 패턴

## 데이터 접근에 DIP 적용

계층 아키텍처는 UI, 비즈니스 로직, 데이터베이스로 이루어진 시스템을 구조화할 때 일반적으로 쓰인다.

도메인 모델은 각 계층의 어떤 의존성도 없도록 해야 한다. 하부 구조와 관련된 문제가 도메인 모델에 지속적으로 영향을 끼쳐서 단위 테스트를 느리게 하고 도메인 모델을 변경하는 게 여의치 않으면 안된다.


가장 처음 SQLAlchemy를 이용하여 ORM을 사용한다고 하면

```python
from sqlalchemy import Column, ForeignKey, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class Order(Base):
    id = Column(Integer, primary_key=True)


class OrderLine(Base):
    id = Column(Integer, primary_key=True)
    sku = Column(String(250))
    qty = Column(String(250))
    order_id = Column(Integer, ForeignKey('order.id'))
    order = relationship(Order)
```
과 같이 정의할 수 있다.

모델 클래스가 ORM 클래스를 직접 상속한다. 따라서 이 모델은 ORM에 의존한다고 볼 수 있다.

이와 반대로 모델에 의존하는 ORM을 구현한다면 아래와 같을 것이다.

```python
from sqlalchemy.rom import mapper, relationship

import model

metadata = MetaData()

order_lines = Table(
    'order_lines', metadata,
    Column('id', Integer, primary_key=True, autoincrement=True),
    Column('sku', String(255)),
    Column('qty', Integer, nullable=False),
    Column('orderid', String(255))
)

def start_mappers():
    lines_mapper = mapper(model.OrderLine, order_lines)
```

이렇게 되면 도메인 모델이 ORM을 임포트하는 것이 아니라 ORM이 도메인 모델을 임포트한다. mapper함수를 호출할 때 SQLAlchemy는 사용자가 정의한 여러 테이블에 도메인 클래스를 연결한다.

또 SQLAlchemy를 제거하고 다른 ORM을 사용할 때 도메인 모델의 변경없이 쉽게 변경할 수 있다.

---

## 저장소 패턴

**저장소 패턴**은 영속적 저장소를 추상화하여 모든 데이터가 메모리 상에 존재하는 것처럼 가정해 데이터 접근과 관련된 세부사항을 감춘다.

```python
class SQLAlchemyRepository(BaseRepository):
    def __init__(self, session):
        self.session = session

    def add(self, batch):
        self.session.add(batch)
    
    def get(self, reference):
        return self.session.query(model.Batch).filter_by(reference=reference).one()

    def list(self):
        return self.session.query(model.Batch).all()

```